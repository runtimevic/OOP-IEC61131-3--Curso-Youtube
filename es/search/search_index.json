{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduccion","text":"<p> \ud83d\udcd6 Curso Programaci\u00f3n Orientada a Objetos Youtube -- OOP : </p> <p>  by Runtimevic -- V\u00edctor Dur\u00e1n Mu\u00f1oz. </p>"},{"location":"#que-es-oop","title":"\u00bf Qu\u00e9 es OOP?","text":"<ul> <li> <p>Es un paradigma que hace uso de los objetos para la construcci\u00f3n de los software.</p> <p>. \u00bf Qu\u00e9 es un paradigma?</p> <ul> <li>Tiene diferentes interpretaciones, puede ser un modelo, ejemplo o patr\u00f3n.</li> <li>Es una forma o un estilo de programar.</li> <li>se busca plasmar la realidad hacia el c\u00f3digo.</li> </ul> </li> </ul>"},{"location":"#como-pensar-en-objetos","title":"\u00bfC\u00f3mo pensar en Objetos?","text":"<ul> <li>Enfocarse en algo de la realidad.</li> <li>Detalla sus atributos, (propiedades)</li> <li>Detalla sus comportamientos (metodos)</li> </ul> <pre><code>\ud83d\udcf1 Ejemplo: (Telefono m\u00f3vil-smartphone)\n\n. \u00bfQu\u00e9 atributos (Propiedades) reconocemos? \n    - color.\n    - marca.\n. \u00bfQu\u00e9 se puede hacer? (Metodos)\n    - Realizar llamadas.\n    - Navegar por internet. \n</code></pre> <pre><code>\ud83d\ude97 Ejemplo: (Coche)\n\n. \u00bfQu\u00e9 atributos (Propiedades) reconocemos? \n    - color.\n    - marca.\n. \u00bfQu\u00e9 se puede hacer? (Metodos)\n    - conducir.\n    - frenar. \n    - acelerar.\n</code></pre>"},{"location":"#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 Codesys admite OOP</p> </li> <li> <p>\ud83d\udd17 Beckhoff TwinCAT 3 admite OOP</p> </li> <li> <p>\ud83d\udd17 Why Object Oriented PLC Programming is Essential for Industrial Automation</p> </li> <li> <p>\ud83d\udd17 cascadingsoft.com,object-oriented-programming-oop-concepts-benefit</p> </li> <li> <p>\ud83d\udd17 object-oriented-programming-in-plc-ooip-or-oops-supported-plc</p> </li> <li> <p>\ud83d\udd17 The Benefits of OOP in PLC Programming: A Case Study with a Conveyor System</p> </li> <li> <p>\ud83d\udd17 Fundamental Concepts of Object Oriented Programming</p> </li> </ul>"},{"location":"#link-al-video-de-youtube-001","title":"Link al Video de Youtube 001:","text":"<ul> <li>\ud83d\udd17 001 - OOP IEC 61131-3 PLC -- Introducci\u00f3n a la pagina de documentaci\u00f3n SSG, repositorio...</li> </ul>"},{"location":"Extended_Structured_Text/","title":"Texto Estructurado Extendido","text":""},{"location":"Extended_Structured_Text/#exst-texto-estructurado-extendido","title":"ExST - Texto Estructurado Extendido:","text":"<ul> <li>El Texto Estructurado Extendido (ExST) es una extensi\u00f3n espec\u00edfica de CODESYS, que la empresa 3S ha implementado en CODESYS. </li> <li>Adem\u00e1s del lenguaje b\u00e1sico de  IEC 61131-3, se han agregado algunos elementos de control interesantes, tan \u00fatiles para el uso diario que me gustar\u00eda present\u00e1rselos directamente.</li> <li>Tambi\u00e9n tenemos ExST disponible para TwinCAT3.</li> </ul>"},{"location":"Extended_Structured_Text/#asignacion-extendida-como-expresion","title":"Asignaci\u00f3n Extendida como Expresi\u00f3n:","text":"<ul> <li>En ExST, como extensi\u00f3n del est\u00e1ndar IEC 61131-3, CODESYS, TwinCAT permite el uso de asignaciones como expresiones.</li> </ul> <p>Ejemplo: <pre><code>myVar := myVar1 := myVar2 + 26 ; // asignaci\u00f3n extendida \n</code></pre></p> <ul> <li>En este ejemplo, las variables myVar y myVar1 reciben el valor de la variable myVar2 sumado a 26.</li> </ul> <p>Tabla de Ejemplos:</p> Ejemplo Comentario int_var1 := int_var2 := int_var3 + 9; ( int_var1 y int_var2 recibe el valor de int_var3 + 9 ) real_var1 := real_var2 := int_var; ( real_var1 y real_var2 recibe el valor de int_var ) int_var := real_var1 := int_var; ( asignaci\u00f3n incorrecta, \u00a1los tipos de datos no corresponden! ) IF b := (i = 1) THEN i := i + 1; END_IF <ul> <li>Hasta ahora, la asignaci\u00f3n siempre se ha hecho con \":=\" El valor del lado derecho se asigna a la variable del lado izquierdo.</li> </ul>"},{"location":"Extended_Structured_Text/#s","title":"S=","text":"<ul> <li>Sin embargo, tambi\u00e9n puede realizar la asignaci\u00f3n utilizando \"S=\".</li> <li>Este operador establece una variable.</li> <li>Cuando el valor de la variable a la izquierda de \"S=\" se convierte en TRUE una vez, sigue siendo TRUE, incluso si el operando a la derecha de \"S=\" vuelve a FALSE.</li> </ul> <p>Sintaxis: <pre><code>&lt;variable1&gt; S= &lt;variable2&gt;;\n</code></pre> Ejemplo: <pre><code>bVar1 S= bVar2;\n</code></pre></p> <ul> <li>bVar1 obtiene el valor de bVar2. Una vez que bVar1 se ha establecido en TRUE, bVar1 permanece TRUE aunque vuelva bVar2 a ser FALSE.</li> </ul>"},{"location":"Extended_Structured_Text/#r","title":"R=","text":"<ul> <li>El operador de asignaci\u00f3n \"R=\" es el opuesto de \"S=\".</li> <li>Esta asignaci\u00f3n restablece una variable. </li> <li>Una vez que el valor de la variable a la izquierda de \"R=\" se ha convertido en FALSE, permanece FALSE incluso si el operando a la derecha de \"R=\" vuelve a cambiar a TRUE .</li> </ul> <p>Sintaxis: <pre><code>&lt;variable1&gt; R= &lt;variable2&gt;;\n</code></pre> Ejemplo: <pre><code>bVar11 R= bVar22;\n</code></pre></p> <ul> <li>bVar11 obtiene el valor de bVar22. Una vez que bVar11 se ha establecido en FALSE, bVar11 permanece FALSE aunque vuelva bVar22 a ser TRUE.</li> </ul> <p>El uso de \"S=\" y \"R=\" en una concatenaci\u00f3n es interesante. Si aplica el operador Set a una variable y el operador Reset a otra en una l\u00ednea, la referencia siempre es al \u00faltimo elemento de la serie de asignaci\u00f3n.</p> <p>Ejemplo: <pre><code>bVar1 S= bVar2 R= F_Fun1(nPar1, nPar2);\n</code></pre></p> <ul> <li>Todas las asignaciones de configuraci\u00f3n y restablecimiento siempre hacen referencia al \u00faltimo elemento de la asignaci\u00f3n. Ejemplo: En este caso, bVar2 obtiene la salida de F_Fun1 resultante del reinicio, pero: bVar1 no obtiene el resultado del conjunto de bVar2, sino el resultado del conjunto de F_Fun1!</li> </ul> <pre><code>bMyVar1 S= bMyVar2 R= myTimer.Q;\n</code></pre> <ul> <li> <p>Aqu\u00ed bMyVar2 se restablece cuando el tiempo establecido en el m\u00f3dulo temporizador ha expirado.</p> </li> <li> <p>\u00a1\u00a1Atenci\u00f3n!! La variable bMyVar1 ahora no se establece si bMyVar2 tiene el valor TRUE, pero los operadores de asignaci\u00f3n siempre act\u00faan en el bloque del temporizador.</p> </li> </ul>"},{"location":"Extended_Structured_Text/#links-exst","title":"Links ExST:","text":"<ul> <li>\ud83d\udd17 Threes Soup01, Beckhoff.Tutorial About TwinCAT3 ExST</li> <li>\ud83d\udd17 Threes Soup01, Beckhoff.TwinCAT ExST \u4f7f\u3063\u3066\u307f\u3088\u3046</li> <li>\ud83d\udd17 Structured Text and Extended Structured Text (ExST), infosys.beckhoff.com</li> <li>\ud83d\udd17 infosys.beckhoff.com, ExST</li> <li>\ud83d\udd17 help.codesys.com, ExST</li> <li>\ud83d\udd17 www.codesys-blog.com, ExST</li> <li>\ud83d\udd17 Texto estructurado (ST), Texto estructurado extendido (ExST)</li> </ul>"},{"location":"Extended_Structured_Text/#links-video-de-youtube-019","title":"Links Video de Youtube 019 :","text":"<ul> <li>\ud83d\udd17 019 - OOP IEC 61131-3 PLC -- ExST Texto Estructurado Extendido</li> </ul>"},{"location":"Librerias/","title":"Librerias","text":""},{"location":"Librerias/#librerias","title":"Librerias:","text":"<p>Cuando desarrollas un proyecto, \u00bfqu\u00e9 haces cuando quieres reutilizar el mismo programa para otro proyecto? Probablemente el m\u00e1s com\u00fan es copiar y pegar. Esto est\u00e1 bien para proyectos peque\u00f1os, pero a medida que crece la aplicaci\u00f3n, las bibliotecas nos permiten administrar las funciones y los bloques de funciones que hemos creado.</p> <p>Mediante el uso de bibliotecas, podemos administrar el software que hemos creado en m\u00faltiples proyectos. En primer lugar, es un hecho que diferentes dispositivos tendr\u00e1n diferentes funciones, pero aun as\u00ed, siempre habr\u00e1 partes comunes. En el mundo del desarrollo de software, ese concepto de gesti\u00f3n de bibliotecas es bastante com\u00fan.</p>"},{"location":"Librerias/#cuales-son-las-ventajas-de-usar-la-biblioteca","title":"\u00bfCu\u00e1les son las ventajas de usar la biblioteca?","text":"<ul> <li>El software es modular, por ejemplo, si tengo software para cilindros, puedo usar la biblioteca de cilindros, y si tengo software para registro, puedo usar la biblioteca de registro.</li> <li>Cada biblioteca se prueba de forma independiente.</li> </ul>"},{"location":"Librerias/#links-librerias","title":"Links Librerias:","text":"<ul> <li>\ud83d\udd17 soup01.com,beckhofftwincat3-library-management</li> <li>\ud83d\udd17 PLC programming using TwinCAT 3 - Libraries (Part 11/18)</li> <li>\ud83d\udd17 help.codesys.com,_cds_obj_library_manager/</li> <li>\ud83d\udd17 help.codesys.com,_cds_library_development_information/</li> <li>\ud83d\udd17 help.codesys.com,_tm_test_action_libraries_addlibrary</li> <li>\ud83d\udd17 CODESYS Webinar Library Management Basics</li> <li>\ud83d\udd17 CoDeSys - How to add libraries and more with Machine Control Studio.</li> <li>\ud83d\udd17 SPT Application Framework Documentation</li> <li>\ud83d\udd17 Beckhoff.SPT Framework Tutorial Part1.EN</li> </ul>"},{"location":"Librerias/#link-al-video-de-youtube-xxx","title":"Link al Video de Youtube xxx:","text":"<p><pre><code>!!! mirar este video por ejemplo para empezar como concepto a realizar las librerias!!!\n</code></pre> - \ud83d\udd17 Nguy\u1ec5n V\u1ef9, Beckhoff &amp; PLC - OOP Properties| TWINCAT3</p> <ul> <li>\ud83d\udd17 The Benefits of OOP in PLC Programming: A Case Study with a Conveyor System</li> </ul>"},{"location":"Tipos%20de%20Dise%C3%B1o%20para%20programacion%20de%20PLC/","title":"Tipos de Dise\u00f1o para programacion de PLC","text":""},{"location":"Tipos%20de%20Dise%C3%B1o%20para%20programacion%20de%20PLC/#tipos-de-diseno-para-programacion-de-plc","title":"Tipos de Dise\u00f1o para programacion de PLC:","text":"<p>!!! explicar lo del curso de C# de OOP de Nem\u00ed !!!!.</p> <p>\ud83d\ude80 \ud835\uddea\ud835\uddf5\ud835\uddee\ud835\ude01'\ud835\ude00 \ud835\uddee \ud835\udde6\ud835\uddfc\ud835\uddf3\ud835\ude01\ud835\ude04\ud835\uddee\ud835\uddff\ud835\uddf2 \ud835\udde8\ud835\uddfb\ud835\uddf6\ud835\ude01 ?</p> <p>In software development, understanding what is a \"Software Unit\" is essential, but it's not always as straightforward as it may seem. What are the challenges and solutions of defining this critical building block according to ISO 26262?</p> <p>\ud83e\udde9 \ud835\udddc\ud835\udde6\ud835\udde2 \ud835\udfee\ud835\udff2\ud835\udfee\ud835\udff2\ud835\udfee \ud835\uddf1\ud835\uddf2\ud835\uddf3\ud835\uddf6\ud835\uddfb\ud835\uddf6\ud835\ude01\ud835\uddf6\ud835\uddfc\ud835\uddfb</p> <p>A software unit is the atomic level of a software component, eligible for standalone testing. It encapsulates specific functionalities and is designed for independent development and testing. Several software units collectively form a software component.</p> <p>\ud83c\udfaf \ud835\uddd6\ud835\uddf5\ud835\uddee\ud835\uddff\ud835\uddee\ud835\uddf0\ud835\ude01\ud835\uddf2\ud835\uddff\ud835\uddf6\ud835\ude00\ud835\ude01\ud835\uddf6\ud835\uddf0\ud835\ude00 \ud835\uddfc\ud835\uddf3 \ud835\uddee \ud835\udde6\ud835\uddfc\ud835\uddf3\ud835\ude01\ud835\ude04\ud835\uddee\ud835\uddff\ud835\uddf2 \ud835\udde8\ud835\uddfb\ud835\uddf6\ud835\ude01</p> <p>1\ufe0f\u20e3 \ud835\udddc\ud835\uddfb\ud835\uddf1\ud835\uddf2\ud835\uddfd\ud835\uddf2\ud835\uddfb\ud835\uddf1\ud835\uddf2\ud835\uddfb\ud835\uddf0\ud835\uddf2: It can be designed, implemented, and tested separately, making it developer-friendly.</p> <p>2\ufe0f\u20e3 \ud835\udde5\ud835\uddf2\ud835\uddfe\ud835\ude02\ud835\uddf6\ud835\uddff\ud835\uddf2\ud835\uddfa\ud835\uddf2\ud835\uddfb\ud835\ude01\ud835\ude00 \ud835\uddd9\ud835\uddfc\ud835\uddf0\ud835\ude02\ud835\ude00: It exhaustively fulfills a set of well-defined requirements, ensuring traceability.</p> <p>3\ufe0f\u20e3 \ud835\udde6\ud835\uddf2\ud835\uddf9\ud835\uddf3-\ud835\uddd6\ud835\uddfc\ud835\uddf5\ud835\uddf2\ud835\ude00\ud835\uddf6\ud835\uddfc\ud835\uddfb: It's highly atomic, focusing on a single functionality with minimal dependencies.</p> <p>4\ufe0f\u20e3 \ud835\udde5\ud835\uddf2\ud835\ude02\ud835\ude00\ud835\uddee\ud835\uddef\ud835\uddf6\ud835\uddf9\ud835\uddf6\ud835\ude01\ud835\ude06: It's designed to be reused if necessary across multiple software applications for more efficiency.</p> <p>\ud83d\udcd0 \ud835\udde6\ud835\uddf6\ud835\ude07\ud835\uddf2 \ud835\uddee\ud835\uddfb\ud835\uddf1 \ud835\uddd6\ud835\uddfc\ud835\uddfa\ud835\uddfd\ud835\uddf9\ud835\uddf2\ud835\ude05\ud835\uddf6\ud835\ude01\ud835\ude06</p> <p>Here's the main challenge: defining the ideal size and managing complexity. There\u2019s no exact science but ISO 26262 provides guidelines which include: 1\ufe0f\u20e3 \ud835\uddd4\ud835\uddfb\ud835\uddee\ud835\uddf9\ud835\ude06\ud835\ude07\ud835\uddee\ud835\uddef\ud835\uddf6\ud835\uddf9\ud835\uddf6\ud835\ude01\ud835\ude06: Ensuring the unit's size allows easy analysis and comprehension of allocated requirements.</p> <p>2\ufe0f\u20e3 \ud835\uddd9\ud835\ude02\ud835\uddfb\ud835\uddf0\ud835\ude01\ud835\uddf6\ud835\uddfc\ud835\uddfb\ud835\uddee\ud835\uddf9\ud835\uddf6\ud835\ude01\ud835\ude06 \ud835\uddd6\ud835\uddfc\ud835\uddfb\ud835\ude00\ud835\uddf6\ud835\uddf1\ud835\uddf2\ud835\uddff\ud835\uddee\ud835\ude01\ud835\uddf6\ud835\uddfc\ud835\uddfb: Choosing the right algorithm considering the constraints of embedded software (e.g. available hardware ressources)</p> <p>3\ufe0f\u20e3 \ud835\udde6\ud835\uddfa\ud835\uddee\ud835\uddff\ud835\ude01 \ud835\uddd6\ud835\uddfc\ud835\ude02\ud835\uddfd\ud835\uddf9\ud835\uddf6\ud835\uddfb\ud835\uddf4: Grouping highly dependent functionalities within a unit while separating decoupled features into different units.</p> <p>4\ufe0f\u20e3 \ud835\udde7\ud835\uddf2\ud835\uddf0\ud835\uddf5\ud835\uddfb\ud835\uddf6\ud835\uddf0\ud835\uddee\ud835\uddf9 \ud835\uddd6\ud835\uddff\ud835\uddf6\ud835\ude01\ud835\uddf2\ud835\uddff\ud835\uddf6\ud835\uddee: Using metrics, complexity analysis tools, resource limits, and partitioning techniques to guide the software unit design.</p> <p>In the constantly evolving software landscape, understanding the challenges of defining software units is fondamental to create robust, efficient, and scalable software systems. For more details about software unit creation in model-based software development, here\u2019s an interesting blog article: https://lnkd.in/eRipc_MQ</p> <p>Ingenieria de desarrollo para la programaci\u00f3n OOP: - Dise\u00f1o por Componente, Unidad, Dispositivo, Objeto...     - Los objetos son las unidades b\u00e1sicas de la programaci\u00f3n orientada a objetos.     - Un componente proporciona servicios, mientras que un objeto proporciona operaciones y m\u00e9todos. Un componente puede ser entendido por todos, mientras que un objeto solo puede ser entendido por los desarrolladores.     - Las unidades son los grupos de c\u00f3digo m\u00e1s peque\u00f1os que se pueden mantener y ejecutar de forma independiente - Dise\u00f1o por Pruebas Unitarias. - Dise\u00f1o en UML.</p> <p>Units: (Ejemplo de Unidades): - I_InputDigital(p_On, p_Off) - I_OutputDigital(M_ON, M_OFF) - I_InputAnalog - I_OutputAnalog - I_Run:(M_Start, M_Stop)</p> <p>-FBTimer -FCAnalogSensor -FBGenericUnit</p> <p>!!! puntos que se pueden incluir en el curso!!!: - Objects composition (Composicion de Objetos)</p> <ul> <li>Basic of Structured Text programming Language</li> <li>UDT (estructuras)</li> <li>Modular Design</li> <li> <p>Polymorphism</p> </li> <li> <p>Advanced State Pattern</p> </li> <li>Wrappers and Features</li> <li>Layered Design</li> <li>Final Project covering a real-world problem to be solved using OOP</li> </ul> <ul> <li>www.btc-embedded.com, component-based-architecture-in-simulink-for-efficient-unit-and-integration-test</li> </ul>"},{"location":"links/","title":"Links","text":""},{"location":"links/#links-de-oop","title":"Links de OOP:","text":""},{"location":"links/#mencion-a-la-fuentes-links-empleadas-para-la-realizacion-de-esta-documentacion","title":"Menci\u00f3n a la Fuentes Links empleadas para la realizaci\u00f3n de esta Documentaci\u00f3n:","text":"<ul> <li>https://github.com/benhar-dev/twincat-resources</li> </ul>"},{"location":"requisitos/","title":"Requisitos","text":"<p> \ud83d\udc68\u200d\ud83c\udf93 Requisitos \ud83d\udc69\u200d\ud83c\udf93 : </p> <p></p> <p>Los requisitos necesarios para seguir este curso ser\u00edan tener instalados los siguientes softwares:</p> <ul> <li>\ud83d\udd17 Beckhoff TwinCAT 3 XAE \u00f3 el IDE de \ud83d\udd17 Codesys.</li> <li>Tener cuenta de usuario creada en \ud83d\udd17 GitHub.</li> <li> <p>saber lo m\u00ednimo de Git o apoyarse en herramientas visuales como pueden ser:</p> <ul> <li>\ud83d\udd17 GitHub Desktop.</li> <li>\ud83d\udd17 sourcetree</li> <li>\ud83d\udd17 tortoiseGit, etc...</li> <li>Ser\u00eda bueno tener algo de conocimientos previos de teoria de OOP, aunque sean en otros lenguajes de programaci\u00f3n ya que seran extrapolables para el enfoque de este curso de OOP IEC61131-3 para PLCs.</li> </ul> </li> </ul>"},{"location":"requisitos/#pasos-para-empezar","title":"Pasos para empezar:","text":"<ul> <li> <p>Clonar el repositorio de \ud83d\udd17GitHub:</p> <p>$ git clone https://github.com/runtimevic/OOP-IEC61131-3--Curso-Youtube.git</p> <p>\u00f3 utilizar por ejemplo GitHub Desktop para Clonar el repositorio de GitHub...</p> </li> <li> <p>Nos encontraremos las siguientes carpetas:</p> <ul> <li>\ud83d\udd17 TC3_OOP: Dentro de esta carpeta se encuentra el proyecto de TwinCAT3, con todo lo que se va explicando en los videos de youtube...</li> <li>\ud83d\udd17 Ficheros_PLCOpen_XML: Dentro de esta carpeta nos iremos encontrando los ficheros exportados en formato PLCOpen XML para que puedan ser importados en TwinCAT3 \u00f3 en Codesys de todo lo explicado en Youtube, ya que al ser el formato standarizado de PLCOpen se puede exportar/importar en todas las marcas de PLCs que sigan el estandard PLCOpen..., pero es recomendable intentar realizar lo explicado desde cero para ir practicando y asumir los conceptos explicados...</li> <li>tambien esta alojada la creaci\u00f3n de esta pagina web SSG, (Generador de Sitios Est\u00e1ticos) la cual se ira modificando conforme avancemos en este Curso de OOP IEC-61131-3 PLC...</li> </ul> </li> </ul>"},{"location":"requisitos/#link-al-video-de-youtube-001","title":"Link al Video de Youtube 001:","text":"<ul> <li>\ud83d\udd17 001 - OOP IEC 61131-3 PLC -- Introducci\u00f3n a la pagina de documentaci\u00f3n SSG, repositorio...</li> </ul>"},{"location":"tipos%20de%20paradigmas/","title":"Tipos de paradigmas","text":""},{"location":"tipos%20de%20paradigmas/#tipos-de-paradigmas","title":"Tipos de paradigmas:","text":"<ul> <li>Imperativa -- (Instrucciones a seguir para dar soluci\u00f3n a un problema).</li> <li>Declarativa -- (Se enfoca en el problema a solucionar).</li> <li>Estructurada -- (La soluci\u00f3n a un problema sigue una secuencia de inico a fin).</li> <li> <p>Funcional -- (Divide el problema en diversas soluciones que ser\u00e1n ejecutadas por las funciones declaradas). La programaci\u00f3n procedimental o programaci\u00f3n por procedimientos es un paradigma de la programaci\u00f3n. Muchas veces es aplicable tanto en lenguajes de programaci\u00f3n de bajo nivel como en lenguajes de alto nivel. En el caso de que esta t\u00e9cnica se aplique en lenguajes de alto nivel, recibir\u00e1 el nombre de programaci\u00f3n funcional.</p> <ul> <li>se llaman rutinas separadas desde el programa principal</li> <li>datos en su mayor\u00eda globales -&gt; sin protecci\u00f3n.</li> <li>los procedimientos por lo general no pueden ser independientes -&gt; mala reutilizaci\u00f3n del c\u00f3digo.</li> </ul> </li> </ul> <p></p> <ul> <li> Orientada a objetos  -- Construye soluciones basadas en objetos. <pre><code>wikipedia:\nLa programaci\u00f3n orientada a objetos es un paradigma de programaci\u00f3n\nbasado en el concepto de \"objetos\", que pueden contener datos y c\u00f3digo.\nLos datos est\u00e1n en forma de campos y el c\u00f3digo est\u00e1 en forma de procedimientos.\n</code></pre></li> </ul> <p></p>"},{"location":"tipos%20de%20paradigmas/#ventajas-de-la-programacion-oop","title":"Ventajas de la Programaci\u00f3n OOP:","text":"<ul> <li>rutinas y datos se combinan en un objeto -&gt; Encapsulaci\u00f3n.</li> <li>m\u00e9todos/Propiedades -&gt; interfaces definidas para llamadas y acceso a datos.</li> </ul>"},{"location":"tipos%20de%20paradigmas/#link-tipos-de-paradigmas","title":"Link Tipos de Paradigmas:","text":"<ul> <li>\ud83d\udd17 Programaci\u00f3n funcional \u00bfQu\u00e9 es y c\u00f3mo sacarle partido?</li> </ul>"},{"location":"tipos%20de%20paradigmas/#link-al-video-de-youtube-002-y-003","title":"Link al Video de Youtube 002 y 003:","text":"<ul> <li>\ud83d\udd17 002 - OOP IEC 61131-3 PLC -- Clase y Objeto</li> <li>\ud83d\udd17 003 - OOP IEC 61131-3 PLC -- Clase y Objeto</li> </ul>"},{"location":"CI_CD/Git/","title":"Git","text":"<ul> <li>soup01.com, beckhofflets-try-source-control-with-git-2</li> </ul>"},{"location":"CI_CD/Integracion%20y%20entrega%20continua/","title":"CI/CD - Integraci\u00f3n y entrega continua","text":""},{"location":"CI_CD/Integracion%20y%20entrega%20continua/#links-cicd","title":"Links CI/CD:","text":"<ul> <li>\ud83d\udd17 www.redhat.com,what-is-ci-cd</li> <li>\ud83d\udd17 \u00bfQUE ES CI/CD?</li> <li>\ud83d\udd17 Integraci\u00f3n y Entrega Continua desde cero | Live \ud83d\udd34</li> </ul>"},{"location":"CI_CD/Simulacion/","title":"Simulacion","text":"<ul> <li>Machine simulation with CODESYS applications EN - CODESYS Technology Day 2023</li> </ul>"},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/","title":"Constructor y Destructor","text":""},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#metodos-fb_init-fb_reinit-y-fb_exit","title":"M\u00e9todos 'FB_Init', 'FB_Reinit' y 'FB_Exit':","text":""},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#fb_init","title":"FB_Init:","text":"<ul> <li>Dependiendo de la tarea, puede ser necesario que los bloques de funciones requieran par\u00e1metros que solo se usan una vez para las tareas de inicializaci\u00f3n. Una forma posible de pasarlos elegantemente es usar el m\u00e9todo FB_init(). Este m\u00e9todo se ejecuta impl\u00edcitamente una vez antes de que se inicie la tarea del PLC y se puede utilizar para realizar tareas de inicializaci\u00f3n.</li> <li>Tambi\u00e9n es posible sobrescribir FB_init(). En este caso, las mismas variables de entrada deben existir en el mismo orden y ser del mismo tipo de datos que en el FB b\u00e1sico. Sin embargo, se pueden agregar m\u00e1s variables de entrada para que el bloque de funciones derivado reciba par\u00e1metros adicionales.</li> <li>Al pasar los par\u00e1metros por FB_init(),no se pueden leer desde el exterior ni cambiar en tiempo de ejecuci\u00f3n. La \u00fanica excepci\u00f3n ser\u00eda la llamada expl\u00edcita de FB_init() desde la tarea del PLC. Sin embargo, esto debe evitarse principalmente, ya que todas las variables locales de la instancia se reinicializar\u00e1n en este caso. Sin embargo, si a\u00fan debe ser posible el acceso, se pueden crear las propiedades apropiadas para los par\u00e1metros.</li> </ul>"},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#fb_reinit","title":"FB_Reinit:","text":"<p>Si es necesario, debe implementar FB_reinit expl\u00edcitamente. Si este m\u00e9todo est\u00e1 presente, se llama autom\u00e1ticamente despu\u00e9s de que se haya copiado la instancia del bloque de funci\u00f3n correspondiente (llamada impl\u00edcita). Esto sucede durante un cambio en l\u00ednea despu\u00e9s de cambios en la declaraci\u00f3n de bloque de funci\u00f3n (cambio de firma) para reinicializar el nuevo bloque de instancia. Este m\u00e9todo se llama despu\u00e9s de la operaci\u00f3n de copia y debe establecer valores definidos para las variables de la instancia. Por ejemplo, puede inicializar variables en consecuencia en la nueva ubicaci\u00f3n en la memoria o notificar a otras partes de la aplicaci\u00f3n sobre la nueva ubicaci\u00f3n de variables espec\u00edficas en la memoria. Dise\u00f1e la implementaci\u00f3n independientemente del cambio en l\u00ednea. El m\u00e9todo tambi\u00e9n se puede llamar desde la aplicaci\u00f3n en cualquier momento para restablecer una instancia de bloque de funciones a su estado original.</p>"},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#fb_exit","title":"FB_Exit:","text":"<p>Si es necesario, debe implementar FB_exit expl\u00edcitamente. Si este m\u00e9todo est\u00e1 presente, se llama autom\u00e1ticamente (impl\u00edcitamente) antes de que el controlador elimine el c\u00f3digo de la instancia del bloque de funciones (por ejemplo, incluso si TwinCAT cambia del modo Ejecutar al modo de configuraci\u00f3n).</p>"},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 M\u00e9todos FB_init, FB_reinit and FB_exit, Infosys Beckhoff</p> </li> <li> <p>\ud83d\udd17 M\u00e9todos 'FB_Init', 'FB_Reinit' y 'FB_Exit', Codesys</p> </li> <li> <p>\ud83d\udd17 iec-61131-3-parameter-transfer-via-fb_init, stefanhenneken.net</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/Constructor%20y%20Destructor/#link-al-video-de-youtube-003","title":"Link al Video de Youtube 003:","text":"<ul> <li>\ud83d\udd17 003 - OOP IEC 61131-3 PLC -- Clase y Objeto</li> </ul>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/","title":"FB Abstracto vs Interface","text":""},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#fb-abstracto-frente-a-interface","title":"FB Abstracto frente a Interface:","text":"<p>la diferencia entre utilizar un bloque de funci\u00f3n abstracto y una interfaz es que el FB Abstracto es un tipo de plantilla que define un conjunto de variables y par\u00e1metros de entrada/salida para ser utilizados en diferentes partes del programa. </p> <p>Por otro lado, una interfaz define un conjunto de m\u00e9todos y atributos (propiedades) que deben ser implementados por cualquier clase que la implemente. </p> <p>En resumen, los bloques de funci\u00f3n abstractos son \u00fatiles cuando se necesita reutilizar c\u00f3digo en diferentes partes del programa, mientras que las interfaces son \u00fatiles cuando se quiere asegurar que determinadas clases implementen ciertos m\u00e9todos.</p> <p>Imaginar que tienes un programa que controla diferentes tipos de motores, como motores el\u00e9ctricos, motores a gasolina y motores diesel. Para crear una estructura modular y reutilizable, podr\u00edas crear un bloque de funci\u00f3n abstracto llamado \"Controlador de Motor\" que tenga entradas para el tipo de motor, la velocidad y la direcci\u00f3n. Luego, este bloque de funci\u00f3n abstracto puede ser utilizado en diferentes partes del programa para controlar los diferentes motores. El bloque de funci\u00f3n abstracto define una plantilla com\u00fan que se utiliza en diferentes partes del programa. Por otro lado, si quisieras asegurarte de que todas las clases que controlan motores implementen ciertos m\u00e9todos (por ejemplo, un m\u00e9todo para encender el motor y otro para apagarlo), podr\u00edas crear una interfaz llamada \"Controlador de Motor\" que defina estos m\u00e9todos. Luego, cualquier clase que implemente esta interfaz deber\u00e1 implementar estos m\u00e9todos obligatoriamente. En resumen, los bloques de funci\u00f3n abstractos son \u00fatiles cuando se necesita reutilizar c\u00f3digo en diferentes partes del programa, mientras que las interfaces son \u00fatiles cuando se quiere asegurar que determinadas clases implementen ciertos m\u00e9todos.</p> <ul> <li>Los bloques de funciones, los m\u00e9todos y las propiedades se pueden marcar como abstractos. \"desde TwinCAT V3.1 build 4024\".</li> <li>Los FB abstractos solo se pueden usar como FB b\u00e1sicos para la herencia.</li> <li>La instanciaci\u00f3n directa de FBs abstractos no es posible.Por lo tanto, los FB abstractos tienen cierta similitud con las interfaces.</li> </ul> <p>Ahora, la pregunta es en qu\u00e9 caso se debe usar una interfaz y en qu\u00e9 caso un FB abstracto.</p>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#metodos-abstractos","title":"M\u00e9todos abstractos:","text":"<pre><code>METHOD PUBLIC ABSTRACT DoSomething : LREAL\n</code></pre> <ul> <li>Consisten exclusivamente en la declaraci\u00f3n y no contienen ninguna implementaci\u00f3n. El cuerpo del m\u00e9todo est\u00e1 vac\u00edo.</li> <li>Puede ser p\u00fablico , protegido o interno . El modificador de acceso privado no est\u00e1 permitido.</li> <li>No puede ser declarada adicionalmente como definitiva.</li> </ul>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#propiedades-abstractas","title":"Propiedades abstractas:","text":"<pre><code>PROPERTY PUBLIC ABSTRACT nAnyValue : UINT\n</code></pre> <ul> <li>Puede contener getters, setters o ambos.</li> <li>Getter y setter consisten solo en la declaraci\u00f3n y no contienen ninguna implementaci\u00f3n.</li> <li>Puede ser p\u00fablico , protegido o interno . El modificador de acceso privado no est\u00e1 permitido.</li> <li>No puede ser declarada adicionalmente como definitiva .</li> </ul>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#bloques-de-funciones-abstractas","title":"Bloques de funciones abstractas:","text":"<pre><code>FUNCTION_BLOCK PUBLIC ABSTRACT FB_Foo\n</code></pre> <ul> <li>Tan pronto como un m\u00e9todo o una propiedad se declaran como abstractos , el bloque de funciones tambi\u00e9n debe declararse como abstracto .</li> <li>No se pueden crear instancias a partir de FB abstractos. Los FB abstractos solo se pueden usar como FB b\u00e1sicos cuando se heredan.</li> <li>Todos los m\u00e9todos abstractos y todas las propiedades abstractas deben sobrescribirse para crear un FB no abstracto. Un m\u00e9todo abstracto o una propiedad abstracta se convierte en un m\u00e9todo no abstracto o una propiedad no abstracta al sobrescribir.</li> <li>Los bloques de funciones abstractas pueden contener adem\u00e1s m\u00e9todos no abstractos y/o propiedades no abstractas.</li> <li>Si no se sobrescriben todos los m\u00e9todos abstractos o todas las propiedades abstractas durante la herencia, el FB heredado solo puede ser un FB abstracto (concretizaci\u00f3n paso a paso).</li> <li>Se permiten punteros o referencias de tipo FB abstracto. Sin embargo, estos pueden referirse a FB no abstractos y, por lo tanto, llamar a sus m\u00e9todos o propiedades (polimorfismo).</li> </ul>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#diferencias-entre-un-fb-abstracto-y-una-interfaz","title":"Diferencias entre un FB abstracto y una interfaz:","text":"<p>Si un bloque de funciones consta exclusivamente de m\u00e9todos abstractos y propiedades abstractas, entonces no contiene ninguna implementaci\u00f3n y, por lo tanto, tiene cierta similitud con las interfaces. Sin embargo, hay algunas caracter\u00edsticas especiales a considerar en detalle.</p> Interfaz FB Abstracto admite herencia m\u00faltiple + - puede contener variables locales - + puede contener m\u00e9todos no abstractos - + puede contener propiedades no abstractas - + admite m\u00e1s modificadores de acceso adem\u00e1s de p\u00fablico - + aplicable con matriz + solo atrav\u00e9s de PUNTERO <p>La tabla puede dar la impresi\u00f3n de que las interfaces pueden reemplazarse casi por completo por FB abstractos. Sin embargo, las interfaces ofrecen una mayor flexibilidad porque se pueden usar en diferentes jerarqu\u00edas de herencia.</p> <p>Por lo tanto, como desarrollador, desea saber cu\u00e1ndo se debe usar una interfaz y cu\u00e1ndo se debe usar un FB abstracto. La respuesta simple es preferiblemente ambos al mismo tiempo. Esto proporciona una implementaci\u00f3n est\u00e1ndar en el FB base abstracto, lo que facilita su derivaci\u00f3n. Sin embargo, cada desarrollador tiene la libertad de implementar la interfaz directamente.</p>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#ejemplo","title":"Ejemplo:","text":"<p>Los bloques de funciones deben dise\u00f1arse para la gesti\u00f3n de datos de los empleados. Se hace una distinci\u00f3n entre empleados permanentes ( FB_FullTimeEmployee ) y empleados por contrato ( FB_ContractEmployee ). Cada empleado se identifica por su nombre ( sFirstName ), apellido ( sLastName ) y el n\u00famero de personal ( nPersonnelNumber ). Las propiedades correspondientes se proporcionan para este prop\u00f3sito. Adem\u00e1s, se requiere un m\u00e9todo que genere el nombre completo, incluido el n\u00famero de personal, como una cadena formateada ( GetFullName() ). El c\u00e1lculo de los ingresos mensuales se realiza mediante el m\u00e9todo GetMonthlySalary().</p> <p>Lo resolveremos de 3 formas distintas:</p>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#1-enfoque-de-solucion-fb-abstracto","title":"1. Enfoque de soluci\u00f3n: FB abstracto","text":""},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#2-enfoque-de-solucion-interfaz","title":"2. Enfoque de soluci\u00f3n: Interfaz","text":""},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#3-enfoque-de-solucion-combinacion-de-fb-abstracto-e-interfaz","title":"3. Enfoque de soluci\u00f3n: combinaci\u00f3n de FB abstracto e interfaz","text":""},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#resumen-conclusiones","title":"Resumen, Conclusiones:","text":"<ul> <li>Si el usuario no debe crear una instancia propia del FB (porque esto no parece ser \u00fatil), entonces los FB abstractos o las interfaces son \u00fatiles.</li> <li>Si se quiere tener la posibilidad de generalizar en m\u00e1s de un tipo b\u00e1sico, se debe utilizar una interfaz.</li> <li>Si se puede configurar un FB sin implementar m\u00e9todos o propiedades, se debe preferir una interfaz a un FB abstracto.</li> </ul>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#links-fb-abstracto-frente-a-interface","title":"links FB Abstracto frente a Interface:","text":"<ul> <li> <p>\ud83d\udd17 FB abastracto frente a interfaz, stefanhenneken.net</p> </li> <li> <p>\ud83d\udd17 The ABSTRACT keyword, www.plccoder.com </p> </li> <li> <p>\ud83d\udd17 ABSTRACT concept, infosys.beckhoff.com </p> </li> </ul>"},{"location":"Clases%20y%20Objetos/FB%20abstracto%20frente%20a%20interfaz/#link-al-video-de-youtube-013","title":"Link al Video de Youtube 013:","text":"<ul> <li>\ud83d\udd17 013 - OOP IEC 61131-3 PLC -- FB Abstract vs Interface</li> </ul>"},{"location":"Clases%20y%20Objetos/Function%20Block%20Declaracion%20de%20variables/","title":"Bloque de Funcion Declaracion de variables","text":""},{"location":"Clases%20y%20Objetos/Function%20Block%20Declaracion%20de%20variables/#tipos-de-variables-que-se-pueden-declarar-en-un-function_block","title":"Tipos de variables que se pueden declarar en un FUNCTION_BLOCK:","text":"<ul> <li>\ud83d\udd17 Local Variables - VAR</li> <li>\ud83d\udd17 Input Variables - VAR_INPUT</li> <li>\ud83d\udd17 Output Variables - VAR_OUTPUT</li> <li> <p>\ud83d\udd17 Input/Output Variables - VAR_IN_OUT, VAR_IN_OUT CONSTANT</p> </li> <li> <p>\ud83d\udd17 Temporary Variable - VAR_TEMP</p> </li> <li>\ud83d\udd17 Static Variables - VAR_STAT</li> <li>\ud83d\udd17 External Variables - VAR_EXTERNAL</li> <li>\ud83d\udd17 Instance Variables - VAR_INST</li> <li>\ud83d\udd17 Remanent Variables - PERSISTENT, RETAIN</li> <li>\ud83d\udd17 SUPER</li> <li>\ud83d\udd17 THIS</li> <li> <p>\ud83d\udd17 Variable types - attribute keywords</p> <ul> <li>\ud83d\udd17 RETAIN: for remanent variables of type RETAIN</li> <li>\ud83d\udd17 PERSISTENT: for remanent variables of type PERSISTENT</li> <li>\ud83d\udd17 CONSTANT: for constants</li> </ul> </li> <li> <p>Todos estos tipos de variables que se pueden declarar dentro del FB se pueden repetir los mismos tipos de variables dentro del FB, esto podria valer para diferenciar variables del mismo tipo en la zona de declaraci\u00f3n, ser\u00eda meramente indicativo...</p> </li> <li> <p>Ejemplo de declaraci\u00f3n de variables en un FUNCTION_BLOCK: <pre><code>FUNCTION_BLOCK fb_tipos_de_datos\nVAR_INPUT\nbinput : BOOL;\nEND_VAR\nVAR_INPUT\nbinput2 : BOOL;\nEND_VAR\nVAR_OUTPUT\noutput1 : REAL;\nEND_VAR\nVAR_IN_OUT\nin_out1 : LINT;\nEND_VAR\nVAR_IN_OUT CONSTANT\nin_out_constant1 : DINT;\nEND_VAR\nVAR\nvar1 : STRING;\nEND_VAR\nVAR_TEMP\ntemp1 : ULINT;\nEND_VAR\nVAR_STAT\nnVarStat1 : INT;\nEND_VAR\nVAR_EXTERNAL\nnVarExt1 : INT; // 1st external variable\nEND_VAR\nVAR PERSISTENT\nnVarPers1 : DINT; (* 1. Persistent variable *)\nbVarPers2 : BOOL; (* 2. Persistent variable *)\nEND_VAR\nVAR RETAIN\nnRem1 : INT;\nEND_VAR\nVAR CONSTANT\nn : INT:= 10;\nEND_VAR\n</code></pre></p> </li> </ul>"},{"location":"Clases%20y%20Objetos/Function%20Block%20Declaracion%20de%20variables/#link-al-video-de-youtube-004","title":"Link al Video de Youtube 004:","text":"<ul> <li>\ud83d\udd17 004 - OOP IEC 61131-3 PLC -- Clase y Objeto </li> </ul>"},{"location":"Clases%20y%20Objetos/Function%20Block%20Modificadores%20de%20acceso/","title":"Bloque de Funcion Modificadores de acceso","text":""},{"location":"Clases%20y%20Objetos/Function%20Block%20Modificadores%20de%20acceso/#modificadores-de-acceso-bloque-de-funciones","title":"Modificadores de acceso Bloque de Funciones:","text":"<p>Podemos tener 2 modificadores de acceso para el Bloque de Funciones:</p> <ul> <li>PUBLIC: <ul> <li>No hay restricciones, se puede llamar desde cualquier lugar. </li> <li>Si no ponemos nada al declarar el FB es lo mismo que PUBLIC.</li> <li>Cualquiera puede llamar o crear una instancia del FB.</li> <li>Se puede usar para la herencia al ser public. </li> <li>Son accesibles luego de instanciar la clase.</li> <li>Corresponde a la especificaci\u00f3n de modificador sin restricci\u00f3n de acceso.</li> </ul> </li> <li>INTERNAL: <ul> <li>Solo se puede acceder al FB desde el mismo espacio de nombres. </li> <li>Esto permite que el FB este disponible solo dentro de una determinada biblioteca. La configuraci\u00f3n predeterminada donde no se define ning\u00fan especificador de acceso es PUBLIC .</li> <li>El acceso est\u00e1 limitado al espacio de nombres (la biblioteca).</li> </ul> </li> </ul> <p>Podemos tener otros 2 modificadores de acceso para el Bloque de Funciones:</p> <ul> <li>FINAL:<ul> <li>(en TwinCAT 3 no sale por defecto para seleccionarlo al crear un FB, pero se puede a\u00f1adir mas tarde despues de crearlo...) </li> <li>El FB no puede servir como un bloque de funciones principal. </li> <li>Los m\u00e9todos y las propiedades de esta POU no se pueden heredar. </li> <li>FINAL solo est\u00e1 permitido para POU del tipo FUNCTION_BLOCK.</li> <li>No se permite sobrescribir, en un derivado del bloque de funciones. </li> <li>Esto significa que no se puede sobrescribir/extender en una subclase posiblemente existente.    </li> </ul> </li> <li>ABSTRACT:</li> </ul> <p>bloques de funciones abstractas <pre><code>FUNCTION_BLOCK PUBLIC ABSTRACT FB_Foo\n</code></pre>     - Tan pronto como un m\u00e9todo o una propiedad se declaran como abstractos , el bloque de funciones tambi\u00e9n debe declararse como abstracto .     - No se pueden crear instancias a partir de FB abstractos. Los FB abstractos solo se pueden usar como FB b\u00e1sicos cuando se heredan.     - Todos los m\u00e9todos abstractos y todas las propiedades abstractas deben sobrescribirse para crear un FB no abstracto. Un m\u00e9todo abstracto o una propiedad abstracta se convierte en un m\u00e9todo no abstracto o una propiedad no abstracta al sobrescribir.     - Los bloques de funciones abstractas pueden contener adem\u00e1s m\u00e9todos no abstractos y/o propiedades no abstractas.     - Si no se sobrescriben todos los m\u00e9todos abstractos o todas las propiedades abstractas durante la herencia, el FB heredado solo puede ser un FB abstracto (concretizaci\u00f3n paso a paso).     - Se permiten punteros o referencias de tipo FB abstracto. Sin embargo, estos pueden referirse a FB no abstractos y, por lo tanto, llamar a sus m\u00e9todos o propiedades (polimorfismo).</p>"},{"location":"Clases%20y%20Objetos/Function%20Block%20Modificadores%20de%20acceso/#link-al-video-de-youtube-004","title":"Link al Video de Youtube 004:","text":"<ul> <li>\ud83d\udd17 004 - OOP IEC 61131-3 PLC -- Clase y Objeto </li> </ul>"},{"location":"Clases%20y%20Objetos/Function%20Block/","title":"Bloques de Funciones","text":""},{"location":"Clases%20y%20Objetos/Function%20Block/#declaracion-de-un-function-block","title":"Declaracion de un Function Block:","text":"<pre><code>FUNCTION_BLOCK &lt;access specifier&gt; &lt;function block&gt; | EXTENDS &lt;function block&gt; | IMPLEMENTS &lt;comma-separated list of interfaces&gt;\n</code></pre>"},{"location":"Clases%20y%20Objetos/Function%20Block/#implementacion-bloque-de-funciones","title":"Implementaci\u00f3n Bloque de Funciones:","text":"<p> EXTENDS:  - Si en la declaraci\u00f3n de un FUNCTION_BLOCK a\u00f1adimos la palabra EXTENDS seguida del nombre del FB del cual queremos heredar, significa que heredamos todos sus metodos y propiedades.(principio de Herencia) - Un FB solo puede heredar de una Clase FB.</p> <p> IMPLEMENTS:  - Si en la declaraci\u00f3n de un FUNCTION_BLOCK a\u00f1adimos la palabra IMPLEMENTS seguido del nombre de la interfaz o interfaces separadas por comas. - Si en el FB se implementa una interfaz es obligatorio en el FB crear la programaci\u00f3n de los metodos y propiedades de la interfaz implementada.</p> <ul> <li>Ejemplos de declaraci\u00f3n de FUNCTION_BLOCK:</li> </ul> <pre><code>FUNCTION_BLOCK INTERNAL ABSTRACT FB\nFUNCTION_BLOCK INTERNAL FINAL FB\nFUNCTION_BLOCK PUBLIC FINAL FB\nFUNCTION_BLOCK ABSTRACT FB\nFUNCTION_BLOCK PUBLIC ABSTRACT FB\nFUNCTION_BLOCK FB EXTENDS FB1 IMPLEMENTS Interface1, Interface2, Interface3\n</code></pre>"},{"location":"Clases%20y%20Objetos/Function%20Block/#link-al-video-de-youtube-003","title":"Link al Video de Youtube 003:","text":"<ul> <li>\ud83d\udd17 003 - OOP IEC 61131-3 PLC -- Clase y Objeto</li> </ul>"},{"location":"Clases%20y%20Objetos/Function%20Block/#link-al-video-de-youtube-004","title":"Link al Video de Youtube 004:","text":"<ul> <li>\ud83d\udd17 004 - OOP IEC 61131-3 PLC -- Clase y Objeto</li> </ul>"},{"location":"Clases%20y%20Objetos/Interface%20vs%20Herencia/","title":"Interface vs Herencia","text":""},{"location":"Clases%20y%20Objetos/Interface%20vs%20Herencia/#interface-vs-herencia","title":"Interface vs Herencia:","text":""},{"location":"Clases%20y%20Objetos/Interface%20vs%20Herencia/#herencia","title":"Herencia:","text":"<ul> <li>Debemos definir la implementaci\u00f3n de la clase base.</li> <li>Las clases heredadas dependen de la clase base.</li> <li>La jerarquia de herencia profunda produce alta dependencia, y esto no esta bien lo que se busca es una baja dependencia y alta cohesi\u00f3n.</li> <li>La jerarquia de herencia profunda puede complicarse si es necesario cambiar la clase base.</li> <li>La jerarquia de herencia profunda por regla general no deberia pasar de m\u00e1s de 3 niveles de herencia.</li> <li>Administrar el acceso a datos con especificadores de acceso puede ser m\u00e1s dif\u00edcil con una gran herencia.</li> <li>La herencia m\u00faltiple en una misma Clase no es compatible.</li> </ul>"},{"location":"Clases%20y%20Objetos/Interface%20vs%20Herencia/#interface","title":"Interface:","text":"<ul> <li>La clase base (clase abstracta) no tiene implementaci\u00f3n.</li> <li>No hay dependencias entre las clases que implementan la misma interfaz.</li> <li>Se permite la implementaci\u00f3n de m\u00faltiples interfaces en una misma Clase.</li> </ul> <p>Las Interfaces y la Herencia pueden trabajar de la mano, utilizarse a la vez cogiendo de cada una lo mejor posible:</p> <p></p>"},{"location":"Clases%20y%20Objetos/Interface%20vs%20Herencia/#links-interface-vs-herencia","title":"Links Interface vs Herencia:","text":"<ul> <li>\ud83d\udd17 www.techandsolve.com,alta-cohesion-y-bajo-acoplamiento-en-diseno-de-software</li> <li>\ud83d\udd17 object-oriented-programming-plc-using-inheritance-ralph-koettlitz</li> <li>\ud83d\udd17 stefanhenneken.net,iec-61131-3-object-composition-with-the-help-of-interfaces</li> </ul>"},{"location":"Clases%20y%20Objetos/Interface%20vs%20Herencia/#links-videos-de-youtube-015-y-016","title":"Links Videos de Youtube 015 y 016:","text":"<ul> <li>\ud83d\udd17 015 - OOP IEC 61131-3 PLC -- Interface vs Herencia_1</li> <li>\ud83d\udd17 016 - OOP IEC 61131-3 PLC -- Interface vs Herencia_2</li> </ul>"},{"location":"Clases%20y%20Objetos/Interfaz%20fluida/","title":"Interface fluida","text":""},{"location":"Clases%20y%20Objetos/Interfaz%20fluida/#interfaz-fluida","title":"Interfaz Fluida:","text":"<p>Un dise\u00f1o de programaci\u00f3n popular en lenguajes de alto nivel como C# es el llamado 'c\u00f3digo fluido' o 'interfaz fluida'.  \u00bfqu\u00e9 es una interfaz fluida y c\u00f3mo implementarla en texto estructurado? nos centraremos en una implementaci\u00f3n de una interfaz fluida en texto estructurado.</p>"},{"location":"Clases%20y%20Objetos/Interfaz%20fluida/#que-es-una-interfaz-fluida","title":"\u00bfQu\u00e9 es una interfaz fluida?","text":"<p>Seg\u00fan wikipedia:</p> <p>En ingenier\u00eda de software, una interfaz fluida es una API orientada a objetos cuyo dise\u00f1o se basa en gran medida en el encadenamiento de m\u00e9todos. Su objetivo es aumentar la legibilidad del c\u00f3digo mediante la creaci\u00f3n de un lenguaje espec\u00edfico de dominio (DSL). El t\u00e9rmino fue acu\u00f1ado en 2005 por Eric Evans y Martin Fowler.</p> <p>Un buen ejemplo de este 'encadenamiento de m\u00e9todos' se puede ver con las declaraciones LINQ de C#:</p> <p><pre><code>EmployeeNames = EmployeeList.Where(x=\u203a x.Age \u203a 65) .Select(x=\u203a x) .Where(x=\u203a x.YearsOfEmployment \u203a 20) .Select(x=\u203a x.FullName); </code></pre> Al encadenar continuamente los m\u00e9todos, podemos construir nuestra declaraci\u00f3n completa. \u00a1Es bueno saber que una interfaz fluida se usa a menudo junto con un patr\u00f3n de construcci\u00f3n!. Podemos pensar en la interfaz fluida como un concepto, mientras que el encadenamiento de m\u00e9todos es una implementaci\u00f3n. El objetivo del dise\u00f1o fluido de la interfaz es poder aplicar m\u00faltiples propiedades a un objeto conectando los m\u00e9todos con puntos (.) en lugar de tener que aplicar cada m\u00e9todo individualmente.</p>"},{"location":"Clases%20y%20Objetos/Interfaz%20fluida/#por-que-queremos-la-interfaz-fluida","title":"\u00bfPor qu\u00e9 queremos la Interfaz Fluida?","text":"<ul> <li>Por legilibilidad, mas legible.</li> <li>Mas simple.</li> <li>Por mantenimiento.</li> <li>Por claridad.</li> <li>Por facilidad de escribir.</li> <li>F\u00e1cil de extender.</li> </ul>"},{"location":"Clases%20y%20Objetos/Interfaz%20fluida/#como-construimos-una-interfaz-fluida","title":"\u00bfC\u00f3mo construimos una interfaz fluida?","text":"<p>Al hacer que el c\u00f3digo sea comprensible y fluido, la interfaz fluida le da la impresi\u00f3n de que est\u00e1 leyendo una oraci\u00f3n. Para lograr este patr\u00f3n de dise\u00f1o, necesitar\u00eda usar el encadenamiento de m\u00e9todos.</p> <p>En esta t\u00e9cnica, cada m\u00e9todo devuelve un objeto y puede encadenar todos los m\u00e9todos.</p> <ul> <li>veanse los links a los que se hace referencia, veremos un ejemplo en el cual implementaremos una interface fluida para realizar operaciones matematicas...</li> </ul> <p></p>"},{"location":"Clases%20y%20Objetos/Interfaz%20fluida/#links-interface-fluida","title":"Links Interface Fluida:","text":"<ul> <li> <p>\ud83d\udd17 fluent-code, www.plccoder.com</p> </li> <li> <p>\ud83d\udd17 fluent-interface-and-method-chaining-in-twincat-3</p> </li> <li> <p>\ud83d\udd17 tc3-data-logger creado con interface fluida, github.com/benhar-dev</p> </li> <li> <p>\ud83d\udd17 interface fluida por referencia, getting-limits-twincat-ralph-koettlitz</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/Interfaz%20fluida/#link-al-video-de-youtube-014","title":"Link al Video de Youtube 014:","text":"<ul> <li>\ud83d\udd17 014 - OOP IEC 61131-3 PLC -- Interface Fluida</li> </ul>"},{"location":"Clases%20y%20Objetos/Keyword_Abstract/","title":"Palabra clave Abstracto","text":""},{"location":"Clases%20y%20Objetos/Keyword_Abstract/#palabra-clave-abstracto","title":"Palabra Clave Abstracto:","text":""},{"location":"Clases%20y%20Objetos/Keyword_Abstract/#concepto-abstracto","title":"Concepto ABSTRACTO:","text":"<p>La palabra clave ABSTRACT est\u00e1 disponible para bloques de funciones, m\u00e9todos y propiedades. Permite la implementaci\u00f3n de un proyecto PLC con niveles de abstracci\u00f3n. La abstracci\u00f3n es un concepto clave de la programaci\u00f3n orientada a objetos. Los diferentes niveles de abstracci\u00f3n contienen aspectos de implementaci\u00f3n generales o espec\u00edficos.</p>"},{"location":"Clases%20y%20Objetos/Keyword_Abstract/#disponibilidad-abstracto","title":"Disponibilidad ABSTRACTO:","text":"<p>Ya estaba disponible en CODESYS, pero con el lanzamiento de TwinCAT 4024 ahora tambi\u00e9n est\u00e1 disponible en TwinCAT: la palabra clave ABSTRACT. (Disponible en TC3.1 Build 4024).</p>"},{"location":"Clases%20y%20Objetos/Keyword_Abstract/#aplicacion-de-la-abstraccion","title":"Aplicaci\u00f3n de la abstracci\u00f3n:","text":"<p>Es \u00fatil implementar funciones b\u00e1sicas o puntos en com\u00fan de diferentes clases en una clase b\u00e1sica abstracta. Se implementan aspectos espec\u00edficos en subclases no abstractas. El principio es similar al uso de una interfaz. Las interfaces corresponden a clases puramente abstractas que contienen s\u00f3lo m\u00e9todos y propiedades abstractas. Una clase abstracta tambi\u00e9n puede contener m\u00e9todos y propiedades no abstractos.</p> <p>La abstracci\u00f3n y el uso de la palabra clave abstract es una pr\u00e1ctica com\u00fan en OOP y muchos lenguajes de nivel superior como C# lo admiten. A menudo se considera como el cuarto pilar de la programaci\u00f3n orientada a objetos. </p>"},{"location":"Clases%20y%20Objetos/Keyword_Abstract/#por-que-necesitamos-la-abstraccion","title":"\u00bfPor qu\u00e9 necesitamos la abstracci\u00f3n?","text":"<p>Para comprender por qu\u00e9 la abstracci\u00f3n es tan importante en la programaci\u00f3n orientada a objetos, volvamos r\u00e1pidamente a la definici\u00f3n de abstracci\u00f3n. La abstracci\u00f3n consiste en ocultar al usuario detalles de implementaci\u00f3n innecesarios y centrarse en la funcionalidad.</p> <p>Considere un bloque de funciones que implementa una funcionalidad b\u00e1sica de celda de carga. Para usar esto, todo lo que necesitamos saber es que necesita una se\u00f1al de entrada sin procesar y un factor de escala, y nos proporcionar\u00e1 un valor de salida en Newton. No necesitamos saber c\u00f3mo se convierte, filtra y escala el valor de salida. Deja que alguien m\u00e1s se preocupe por eso. No es de influencia en nuestro programa. Solo trabajaremos con una interfaz simple de una celda de carga.</p> <p>Es bueno saber que el uso de abstracciones est\u00e1 estrechamente relacionado con el principio de inversi\u00f3n de dependencia,  uno de los principios SOLID . Esto se vuelve especialmente importante cuando comienzas a trabajar con pruebas unitarias.</p>"},{"location":"Clases%20y%20Objetos/Keyword_Abstract/#reglas-para-el-uso-de-la-palabra-clave-abstract","title":"Reglas para el uso de la palabra clave ABSTRACT:","text":"<ul> <li>Los bloques de funciones abstractas no se pueden instanciar.</li> <li>Los bloques de funciones abstractas pueden contener m\u00e9todos y propiedades abstractos y no abstractos.</li> <li>Los m\u00e9todos abstractos o las propiedades no contienen ninguna implementaci\u00f3n (solo la declaraci\u00f3n).</li> <li>Si un bloque de funciones contiene un m\u00e9todo o propiedad abstracta, debe ser abstracta.</li> <li>Los bloques de funciones abstractas deben extenderse para poder implementar los m\u00e9todos o propiedades abstractas. Por lo tanto: Un FB derivado debe implementar los m\u00e9todos / propiedades de su FB b\u00e1sico o tambi\u00e9n debe definirse como abstracto. Muestra Clase b\u00e1sica abstracta: <pre><code>FUNCTION_BLOCK ABSTRACT FB_System_Base\n</code></pre> Los puntos en com\u00fan de todos los m\u00f3dulos del sistema se implementan en esta clase b\u00e1sica abstracta. Contiene la propiedad no abstracta \"nSystemID\" y el m\u00e9todo abstracto \"Execute\" para esto: <pre><code>PROPERTY nSystemID : UINT\n</code></pre> <pre><code>METHOD ABSTRACT Execute\n</code></pre> mientras que la implementaci\u00f3n de \"nSystemID\" es la misma para todos los sistemas, la implementaci\u00f3n del m\u00e9todo \"Execute\" difiere para los sistemas individuales.</li> </ul> <p>Subclase no abstracta: <pre><code>FUNCTION_BLOCK FB_StackSystem EXTENDS FB_System_Base\n</code></pre> Las clases no abstractas que se derivan de la clase b\u00e1sica se implementan para los sistemas espec\u00edficos. Esta subclase representa una pila. Dado que no es abstracto, debe implementar el m\u00e9todo \"Execute\" que define la ejecuci\u00f3n espec\u00edfica de la pila: <pre><code>METHOD Execute\n</code></pre></p>"},{"location":"Clases%20y%20Objetos/Keyword_Abstract/#ejemplo-de-demostracion-de-la-palabra-clave-abstract-en-twincat","title":"Ejemplo de Demostracion de la palabra clave ABSTRACT en TwinCAT:","text":"<ul> <li>\ud83d\udd17 The ABSTRACT keyword, www.plccoder.com </li> </ul>"},{"location":"Clases%20y%20Objetos/Keyword_Abstract/#links-de-abstract","title":"Links de ABSTRACT:","text":"<ul> <li>\ud83d\udd17 ABSTRACT concept, infosys.beckhoff.com</li> <li>\ud83d\udd17 The ABSTRACT keyword, www.plccoder.com </li> </ul>"},{"location":"Clases%20y%20Objetos/Keyword_Abstract/#link-al-video-de-youtube-012","title":"Link al Video de Youtube 012:","text":"<ul> <li>\ud83d\udd17 012 - OOP IEC 61131-3 PLC -- Abstract</li> </ul>"},{"location":"Clases%20y%20Objetos/Metodo%20Declaracion%20de%20variables/","title":"Metodo Declaracion de variables","text":""},{"location":"Clases%20y%20Objetos/Metodo%20Declaracion%20de%20variables/#tipos-de-variables-que-se-pueden-declarar-en-un-method","title":"Tipos de variables que se pueden declarar en un METHOD:","text":"<ul> <li>\ud83d\udd17 Local Variables - VAR</li> <li>\ud83d\udd17 Input Variables - VAR_INPUT</li> <li>\ud83d\udd17 Output Variables - VAR_OUTPUT</li> <li> <p>\ud83d\udd17 Input/Output Variables - VAR_IN_OUT, VAR_IN_OUT CONSTANT</p> </li> <li> <p>\ud83d\udd17 Temporary Variable - VAR_TEMP</p> </li> <li>\ud83d\udd17 Static Variables - VAR_STAT</li> <li>\ud83d\udd17 External Variables - VAR_EXTERNAL</li> <li>\ud83d\udd17 Instance Variables - VAR_INST</li> <li>\ud83d\udd17 Remanent Variables - PERSISTENT, RETAIN</li> <li>\ud83d\udd17 SUPER</li> <li>\ud83d\udd17 THIS</li> <li> <p>\ud83d\udd17 Variable types - attribute keywords</p> <ul> <li>RETAIN: for remanent variables of type RETAIN</li> <li>PERSISTENT: for remanent variables of type PERSISTENT</li> <li>CONSTANT: for constants</li> </ul> </li> <li> <p>Ejemplo de declaraci\u00f3n de variables en un METHOD: <pre><code>METHOD metodo0_Declaracion_variables\nVAR_INPUT\nbinput : BOOL;\nEND_VAR\nVAR_INPUT\nbinput2 : BOOL;\nEND_VAR\nVAR_OUTPUT\noutput1 : REAL;\nEND_VAR\nVAR_IN_OUT\nin_out1 : LINT;\nEND_VAR\nVAR_IN_OUT CONSTANT\nin_out_constant1 : DINT;\nEND_VAR\nVAR\nvar1 : STRING;\nEND_VAR\n//!!! no se pueden declarar variables TEMPORALES dentro de la zona de declaraci\u00f3n de variables del m\u00e9todo!!!\n//VAR_TEMP\n//  temp1 : ULINT;\n//END_VAR\nVAR_INST\ncounter : INT;\nEND_VAR\nVAR_STAT\nnVarStat1 : INT;\naarray  : ARRAY[1..n] OF INT;\nEND_VAR\nVAR_EXTERNAL\nnVarExt1 : INT; // 1st external variable\nEND_VAR\n//!!! no se pueden declarar variables PERSISTENT ni RETAIN dentro de la zona de declaraci\u00f3n de variables del m\u00e9todo!!!\n//VAR PERSISTENT\n//    nVarPers1 : DINT; (* 1. Persistent variable *)\n//    bVarPers2 : BOOL; (* 2. Persistent variable *)\n//END_VAR\n//VAR RETAIN\n//    nRem1 : INT;\n//END_VAR\nVAR CONSTANT\nn : INT:= 10;\nEND_VAR\n</code></pre></p> </li> </ul>"},{"location":"Clases%20y%20Objetos/Metodo%20Declaracion%20de%20variables/#link-al-video-de-youtube-005","title":"Link al Video de Youtube 005:","text":"<ul> <li>\ud83d\udd17 005 - OOP IEC 61131-3 PLC -- Objeto Metodo </li> </ul>"},{"location":"Clases%20y%20Objetos/Metodo%20Modificadores%20de%20acceso/","title":"Metodo Modificadores de acceso","text":""},{"location":"Clases%20y%20Objetos/Metodo%20Modificadores%20de%20acceso/#especificadores-de-acceso-para-los-metodos","title":"Especificadores de acceso para los Metodos:","text":"<p>La declaraci\u00f3n del m\u00e9todo puede incluir un especificador de acceso opcional. Esto restringe el acceso al m\u00e9todo.</p>"},{"location":"Clases%20y%20Objetos/Metodo%20Modificadores%20de%20acceso/#tipos-de-modificadores-de-acceso-para-el-metodo","title":"Tipos de modificadores de acceso para el M\u00e9todo:","text":"<ul> <li>PUBLIC: <ul> <li>Cualquiera puede llamar al m\u00e9todo, no hay restricciones.</li> </ul> </li> <li>PRIVATE: <ul> <li>Son accesibles solo dentro de su propia Clase (Bloque de Funci\u00f3n).</li> <li>Sin acceso desde la clase heredada.</li> <li>Sin acceso desde el programa principal, desde el MAIN.</li> </ul> </li> <li>PROTECTED: <ul> <li>Accesible desde dentro de su propia Clase.</li> <li>Accesible desde clases heredadas.</li> <li>El acceso est\u00e1 restringido,no se puede acceder desde el programa principal, desde el MAIN.</li> </ul> </li> <li>INTERNAL: <ul> <li>Solo se puede acceder al m\u00e9todo desde el mismo espacio de nombres. Esto permite que los m\u00e9todos est\u00e9n disponibles solo dentro de una determinada biblioteca, por ejemplo.</li> <li>El acceso est\u00e1 limitado al espacio de nombres (la biblioteca).</li> </ul> </li> </ul> <p>La configuraci\u00f3n predeterminada donde no se define ning\u00fan especificador de acceso es PUBLIC .    </p> <ul> <li>FINAL:(se puede a\u00f1adir acompa\u00f1ado con alguno de los anteriores) <ul> <li>El m\u00e9todo no puede ser sobrescrito por otro m\u00e9todo. La sobrescritura de m\u00e9todos se describe a continuaci\u00f3n.</li> <li>No se permite sobrescribir, en un derivado del bloque de funciones. </li> <li>Esto significa que no se puede sobrescribir/extender en una subclase posiblemente existente.</li> </ul> </li> </ul>"},{"location":"Clases%20y%20Objetos/Metodo%20Modificadores%20de%20acceso/#link-al-video-de-youtube-005","title":"Link al Video de Youtube 005:","text":"<ul> <li>\ud83d\udd17 005 - OOP IEC 61131-3 PLC -- Objeto Metodo</li> </ul>"},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/","title":"Metodo tipos de variables de retorno","text":""},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/#tipos-de-variables-de-retorno","title":"Tipos de variables de retorno:","text":"<ul> <li>No es obligatorio en el metodo retornar un tipo de variable.<ul> <li>Ejemplos de declaraci\u00f3n de M\u00e9todos que nos devuelve una variable de diferentes tipos:     <pre><code>METHOD Method1 : BOOL\nMETHOD Method1 : INT\nMETHOD Method1 : REAL\nMETHOD Method1 : STRING\n</code></pre></li> </ul> </li> </ul>"},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/#retorno-por-struct","title":"Retorno por STRUCT:","text":"<p>Acceso a un \u00fanico elemento de un tipo de retorno estructurado durante la llamada a m\u00e9todo/funci\u00f3n/propiedad.</p> <p>La siguiente implementaci\u00f3n se puede utilizar para tener acceso directamente a un elemento individual del tipo de datos estructurado que devuelve el m\u00e9todo/funci\u00f3n/propiedad cuando se llama a un m\u00e9todo, funci\u00f3n o propiedad. </p> <p>Un tipo de datos estructurado es, por ejemplo, una estructura o un bloque de funciones.</p> <p>El tipo devuelto del m\u00e9todo/funci\u00f3n/propiedad se define como: <pre><code>REFERENCE TO &lt;structured type&gt;\n//en lugar de simplemente  \n&lt;structured type&gt;\n</code></pre> Tenga en cuenta que con este tipo de retorno, si, por ejemplo, se va a devolver una instancia local FB del tipo de datos estructurados, se debe usar el operador de referencia REF= en lugar del operador de asignaci\u00f3n \"normal\" :=.</p> <p>Las declaraciones y el ejemplo de esta secci\u00f3n se refieren a la llamada de una propiedad. Sin embargo, son igualmente transferibles a otras llamadas que ofrecen valores devueltos (por ejemplo, m\u00e9todos o funciones).</p>"},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/#ejemplo","title":"Ejemplo:","text":"<p>Declaraci\u00f3n de la estructura ST_Sample (STRUCTURE): <pre><code>TYPE ST_Sample :\nSTRUCT\nbVar  : BOOL;\nnVar  : INT;\nEND_STRUCT\nEND_TYPE\n</code></pre> Declaraci\u00f3n del bloque de funciones FB_Sample: <pre><code>FUNCTION_BLOCK FB_Sample\nVAR\nstLocal     : ST_Sample;\nEND_VAR\n</code></pre> Declaraci\u00f3n de la propiedad FB_Sample.MyProp con el tipo de devoluci\u00f3n \"REFERENCE TO ST_Sample\": <pre><code>PROPERTY MyProp : REFERENCE TO ST_Sample\n</code></pre> Implementaci\u00f3n del m\u00e9todo Get de la propiedad FB_Sample.MyProp: <pre><code>MyProp REF= stLocal;\n</code></pre> Implementaci\u00f3n del m\u00e9todo Set de la propiedad FB_Sample.MyProp: <pre><code>stLocal := MyProp;\n</code></pre> Llamando a los m\u00e9todos Get y Set en el programa principal MAIN: <pre><code>PROGRAM MAIN\nVAR\nfbSample    : FB_Sample;\nnSingleGet  : INT;\nstGet       : ST_Sample;    bSet        : BOOL;\nstSet       : ST_Sample;\nEND_VAR\n// Get - single member and complete structure possible\nnSingleGet := fbSample.MyProp.nVar;\nstGet      := fbSample.MyProp;\n\n// Set - only complete structure possible \nIF bSet THEN\nfbSample.MyProp REF= stSet;\nbSet            := FALSE;\nEND_IF\n</code></pre></p> <p>Mediante la declaraci\u00f3n del tipo devuelto de la propiedad MyProp como \"REFERENCE TO ST_Sample\" y mediante el uso del operador de referencia REF= en el m\u00e9todo Get de esta propiedad, se puede acceder a un \u00fanico elemento del tipo de datos estructurados devuelto directamente al llamar a la propiedad. <pre><code>VAR\nfbSample    : FB_Sample;\nnSingleGet  : INT;\nEND_VAR\nnSingleGet := fbSample.MyProp.nVar;\n</code></pre> Si el tipo de retorno solo se declarara como \"ST_Sample\", la estructura devuelta por la propiedad tendr\u00eda que asignarse primero a una instancia de estructura local. Los elementos de estructura individuales podr\u00edan consultarse sobre la base de la instancia de estructura local. <pre><code>VAR\nfbSample    : FB_Sample; stGet       : ST_Sample; nSingleGet  : INT;\nEND_VAR\nstGet      := fbSample.MyProp;\nnSingleGet := stGet.nVar;\n</code></pre></p>"},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/#retorno-por-interface","title":"Retorno por INTERFACE:","text":"<p>Ejemplo de declaraci\u00f3n de un m\u00e9todo que nos devuelve una variable del tipo INTERFACE. <pre><code>METHOD Method1 : interface1\n</code></pre></p>"},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/#retorno-por-function_block","title":"Retorno por FUNCTION_BLOCK:","text":"<p>Ejemplo de declaraci\u00f3n de un m\u00e9todo que nos devuelve una variable del tipo FUNCTION_BLOCK. <pre><code>METHOD Method1 : FB1\n</code></pre></p>"},{"location":"Clases%20y%20Objetos/Metodo%20Tipos%20de%20variables%20de%20retorno/#link-al-video-de-youtube-005","title":"Link al Video de Youtube 005:","text":"<ul> <li>\ud83d\udd17 005 - OOP IEC 61131-3 PLC -- Objeto Metodo</li> </ul>"},{"location":"Clases%20y%20Objetos/Otros%20Operadores/","title":"Otros Operadores","text":""},{"location":"Clases%20y%20Objetos/Otros%20Operadores/#otros-operadores","title":"Otros Operadores:","text":""},{"location":"Clases%20y%20Objetos/Otros%20Operadores/#__delete","title":"__DELETE:","text":"<ul> <li>El operador es una extensi\u00f3n del est\u00e1ndar IEC 61131-3.</li> <li>El operador libera la memoria de instancias, que el operador __NEW gener\u00f3 din\u00e1micamente. </li> <li>El operador DELETE no tiene valor de retorno y el operando se establece en 0 despu\u00e9s de esta operaci\u00f3n. <pre><code>//Syntax:\n__DELETE (&lt;Pointer&gt;)\n</code></pre></li> <li> <p>Si un puntero apunta a un bloque de funciones, TwinCAT llama al m\u00e9todo correspondiente FB_exit antes de que el puntero se establezca en 0.</p> </li> <li> <p>\ud83d\udd17 __DELETE, infosys.beckhoff.com</p> </li> <li>\ud83d\udd17 __DELETE, help.codesys.com</li> </ul>"},{"location":"Clases%20y%20Objetos/Otros%20Operadores/#__isvalidref","title":"__ISVALIDREF:","text":"<ul> <li>El operador es una extensi\u00f3n del est\u00e1ndar IEC 61131-3.</li> <li>El operador se utiliza para comprobar si una referencia apunta a un valor. Por lo tanto, la verificaci\u00f3n es comparable con una verificaci\u00f3n de 'desigual a 0' en el caso de una variable de puntero.</li> <li>Puede encontrar una descripci\u00f3n de la aplicaci\u00f3n y una muestra del uso del operador en la descripci\u00f3n del tipo de datos REFERENCE.</li> <li>El operador __ISVALIDREF solo se puede utilizar para operandos de tipo REFERENCE TO. Este operador no se puede utilizar para comprobar las variables de la interfaz. Para verificar si a una variable de interfaz ya se le asign\u00f3 una instancia de bloque de funciones, puede verificar que la variable de interfaz no sea igual a 0 (IF iSample &lt;&gt; 0 THEN \u2026). <pre><code>//Syntax: \n&lt;Boolean variable&gt; := __ISVALIDREF(&lt;with REFERENCE TO &lt;data type&gt; declared identifier);\n</code></pre></li> <li>\ud83d\udd17 __ISVALIDREF, infosys.beckhoff.com</li> <li>\ud83d\udd17 __ISVALIDREF, help.codesys.com</li> </ul>"},{"location":"Clases%20y%20Objetos/Otros%20Operadores/#__new","title":"__NEW:","text":"<ul> <li>El operador es una extensi\u00f3n del est\u00e1ndar IEC 61131-3.</li> <li>El operador __NEW asigna memoria para instancias de bloques de funciones o matrices de tipos de datos est\u00e1ndar. El operador devuelve un puntero con tipo adecuado al objeto. Si no utiliza el operador dentro de una asignaci\u00f3n, TwinCAT emite un mensaje de error.</li> <li>Si falla el intento de asignaci\u00f3n de memoria, __NEW devuelve el valor 0.</li> <li>La memoria din\u00e1mica se asigna desde el grupo de memoria del enrutador.</li> <li>Informaci\u00f3n de estado del enrutador TwinCAT : El bloque de funciones FB_GetRouterStatusInfo de la biblioteca Tc2_Utilities se puede utilizar para leer informaci\u00f3n de estado del enrutador TwinCAT, como la memoria del enrutador disponible, desde el PLC. <pre><code>//Syntax:\n__NEW (&lt;Type&gt;,[&lt;Length&gt;])\n</code></pre></li> <li>Ning\u00fan cambio de tipo es posible a trav\u00e9s del cambio en l\u00ednea</li> <li>Un m\u00f3dulo de funci\u00f3n/DUT, que se puede crear con __NEW, ocupa un \u00e1rea de memoria fija. No puede cambiar su dise\u00f1o de datos utilizando la funci\u00f3n de cambio en l\u00ednea. Esto significa que no se pueden agregar nuevas variables, no se pueden eliminar variables y no se pueden cambiar tipos. Esto garantiza que el puntero a este objeto siga siendo v\u00e1lido despu\u00e9s del cambio en l\u00ednea.</li> <li> <p>Por esta raz\u00f3n, el operador __NEW solo se puede aplicar a bloques de funci\u00f3n/DUT de bibliotecas y a bloques de funci\u00f3n/DUT con el {attribute 'enable_dynamic_creation'}. Si se modifica la interfaz de un bloque de funci\u00f3n/DUT de este tipo, TwinCAT emite un mensaje de error.</p> </li> <li> <p>\ud83d\udd17 __NEW, infosys.beckhoff</p> </li> <li>\ud83d\udd17 __NEW, help.codesys.com</li> </ul>"},{"location":"Clases%20y%20Objetos/Otros%20Operadores/#__queryinterface","title":"__QUERYINTERFACE:","text":"<ul> <li>El operador es una extensi\u00f3n del est\u00e1ndar IEC 61131-3.</li> <li>En tiempo de conversi\u00f3n, el operador realiza un tipo de referencia de interfaz a otra. El operador devuelve un resultado de tipo BOOL. TRUE significa que TwinCAT realiz\u00f3 la conversi\u00f3n con \u00e9xito. <pre><code>//Syntax: \n__QUERYINTERFACE(&lt;ITF_Source&gt;,&lt;ITF_Dest&gt;)\n</code></pre></li> <li>1er operando: referencia de interfaz o instancia de FB.</li> <li>2.\u00ba operando: referencia de interfaz con los tipos de destino requeridos.El segundo par\u00e1metro contiene una referencia a la interfaz solicitada.</li> </ul> <p>Un requisito previo para la conversi\u00f3n expl\u00edcita es que tanto ITF_Source como ITF_Dest sean derivados de __System.IQueryInterface. Esta interfaz est\u00e1 impl\u00edcitamente disponible y no requiere biblioteca.</p> <ul> <li>\ud83d\udd17 __QUERYINTERFACE, infosys.beckhoff.com</li> <li>\ud83d\udd17 __QUERYINTERFACE, help.codesys.com</li> </ul>"},{"location":"Clases%20y%20Objetos/Otros%20Operadores/#__querypointer","title":"__QUERYPOINTER:","text":"<ul> <li>El operador es una extensi\u00f3n de IEC61131-3.</li> <li>El operador habilita la conversi\u00f3n de tipo de una referencia de interfaz de un bloque de funciones a un puntero en tiempo de ejecuci\u00f3n. El operador devuelve un resultado de tipo BOOL. TRUE significa que TwinCAT realiz\u00f3 la conversi\u00f3n con \u00e9xito.</li> <li>Por razones de compatibilidad, la definici\u00f3n del puntero a convertir debe ser una extensi\u00f3n de la interfaz b\u00e1sica __SYSTEM.IQueryInterface. <pre><code>//Syntax: \n__QUERYPOINTER (&lt;ITF_Source&gt;, &lt;Pointer_Dest&gt;)\n</code></pre></li> <li>El primer operando asignado al operador es una referencia de interfaz o una instancia de FB con los tipos de destino deseados, el segundo operando es un puntero. Despu\u00e9s de procesar __QUERYPOINTER, Pointer_Dest contiene el puntero a la referencia o instancia de un bloque de funciones, al que apunta actualmente la referencia de interfaz ITF_Source. Pointer_Dest no tiene tipo y se puede convertir a cualquier tipo. Aseg\u00farese de que el tipo sea correcto. Por ejemplo, la interfaz podr\u00eda ofrecer un m\u00e9todo que devuelva un c\u00f3digo de tipo.</li> <li>\ud83d\udd17 __QUERYPOINTER, infosys.beckhoff.com</li> <li>\ud83d\udd17 __QUERYPOINTER, help.codesys.com</li> </ul>"},{"location":"Clases%20y%20Objetos/Otros%20Operadores/#__try-__catch-__finally-__endtry","title":"__TRY, __CATCH, __FINALLY, __ENDTRY:","text":"<ul> <li>Los operadores son una extensi\u00f3n del est\u00e1ndar IEC 61131-3 y se utilizan para un manejo de excepciones espec\u00edfico en el c\u00f3digo IEC.</li> <li>Disponible desde TC3.1 compilaci\u00f3n 4024 para sistemas de tiempo de ejecuci\u00f3n de 32 bits.</li> <li>Ahora tambi\u00e9n est\u00e1 disponible para sistemas de destino de 64 bits a partir de TwinCAT versi\u00f3n 3.1.4026 <pre><code>//Syntax:\n__TRY\n&lt;try_statements&gt;\n\n__CATCH(exc)\n&lt;catch_statements&gt;\n\n__FINALLY\n&lt;finally_statements&gt;\n\n__ENDTRY\n\n&lt;further_statements&gt;\n</code></pre></li> <li> <p>Si una instrucci\u00f3n que aparece bajo el operador __Try genera una excepci\u00f3n, el programa del PLC no se detiene. En su lugar, ejecuta las instrucciones bajo _CATCH y, por lo tanto, inicia el manejo de excepciones. A continuaci\u00f3n, se ejecutan las instrucciones bajo __FINALLY. El manejo de excepciones termina con __ENDTRY. A continuaci\u00f3n, el programa de PLC ejecuta las instrucciones posteriores (instrucciones despu\u00e9s de __ENDTRY).</p> </li> <li> <p>Las instrucciones del bloque _TRY, que se encuentran debajo de la instrucci\u00f3n que desencadena la excepci\u00f3n, ya no se ejecutan. Esto significa que tan pronto como se descarta la excepci\u00f3n, se cancela la ejecuci\u00f3n posterior del bloque _TRY y se ejecutan las instrucciones bajo _CATCH.</p> </li> <li> <p>Las instrucciones bajo _FINALLY siempre se ejecutan, es decir, incluso si las instrucciones bajo _TRY no lanzan ninguna excepci\u00f3n.</p> </li> <li> <p>Una variable IEC para una excepci\u00f3n tiene el tipo de datos __SYSTEM.ExceptionCode.</p> </li> <li>\ud83d\udd17  __TRY, __CATCH, __FINALLY, __ENDTRY, help.codesys.com</li> <li>\ud83d\udd17  __TRY, __CATCH, __FINALLY, __ENDTRY, infosys.beckhoff.com</li> </ul>"},{"location":"Clases%20y%20Objetos/Otros%20Operadores/#__varinfo","title":"__VARINFO:","text":"<ul> <li>El operador es una extensi\u00f3n del est\u00e1ndar IEC 61131-3. </li> <li>El operador devuelve informaci\u00f3n sobre una variable. Puede guardar la informaci\u00f3n como una estructura de datos en una variable de tipo de datos __SYSTEM.VAR_INFO. <pre><code>//Syntax in the declaration:\n&lt;name of the info variable&gt; : __SYSTEM.VAR_INFO; // Data structure for info variable\n\n//Syntax for the call:\n&lt;name of the info variable&gt; := __VARINFO( &lt;variable name&gt; ); // Call of the operator\n</code></pre> <pre><code>//Sample:\n//En tiempo de ejecuci\u00f3n, la variable MyVarInfo contiene la informaci\u00f3n sobre la variable nVar.\n\nVAR\nMyVarInfo : __SYSTEM.VAR_INFO;\nnVar      : INT;\nEND_VAR\nMyVarInfo := __VARINFO(nVar);   </code></pre></li> <li>\ud83d\udd17 __VARINFO, infosys.beckhoff.com</li> <li>\ud83d\udd17 __VARINFO, help.codesys.com</li> </ul>"},{"location":"Clases%20y%20Objetos/Otros%20Operadores/#test_and_set","title":"TEST_AND_SET:","text":"<ul> <li>Puede usar esta funci\u00f3n para verificar y establecer una bandera. No hay opci\u00f3n para interrumpir el proceso. Esto permite sincronizar los accesos a los datos. El modo de operaci\u00f3n de un sem\u00e1foro se puede lograr con TestAndSet.</li> <li>Si la llamada a la funci\u00f3n tiene \u00e9xito, la funci\u00f3n devuelve VERDADERO y se puede acceder a los datos deseados. Si la llamada a la funci\u00f3n no tiene \u00e9xito, la funci\u00f3n devuelve FALSO y no se puede acceder a los datos deseados. En este caso, se debe prever un tratamiento alternativo.</li> </ul> <p>\ud83d\udd17 TEST_AND_SET, Codesys</p> <p>\ud83d\udd17 TESTANDSET, TwinCAT</p> <ul> <li>El bloque de funciones FB_IecCriticalSection ofrece la aplicaci\u00f3n de secciones cr\u00edticas como m\u00e9todo Mutex alternativo.</li> </ul>"},{"location":"Clases%20y%20Objetos/Otros%20Operadores/#links-otros-operadores","title":"Links Otros Operadores:","text":"<ul> <li>\ud83d\udd17 Further operators, infosys.beckhoff.com</li> <li>\ud83d\udd17 Others Operators, help.codesys.com</li> <li>\ud83d\udd17 stefanhenneken.net,iec-61131-3-object-composition-with-the-help-of-interfaces</li> <li>\ud83d\udd17 20. TwinCAT 3: Structures: Alignment &amp; dynamically created structures</li> </ul>"},{"location":"Clases%20y%20Objetos/Otros%20Operadores/#links-videos-de-youtube-016-017-y-018","title":"Links Videos de Youtube 016, 017 y 018:","text":"<ul> <li>\ud83d\udd17 016 - OOP IEC 61131-3 PLC -- Interface vs Herencia_2 </li> <li>\ud83d\udd17 017 - OOP IEC 61131-3 PLC -- Otros Operadores1</li> <li>\ud83d\udd17 018 - OOP IEC 61131-3 PLC -- Otros Operadores2</li> </ul>"},{"location":"Clases%20y%20Objetos/SUPER%20pointer/","title":"SUPER puntero","text":""},{"location":"Clases%20y%20Objetos/SUPER%20pointer/#super-puntero","title":"SUPER^ puntero:","text":"<p>En la programaci\u00f3n orientada a objetos (OOP) en PLCs, el puntero SUPER^ se utiliza para referirse al objeto o instancia de una clase superior o padre. Supongamos que tienes una clase llamada \"Sensor\" y otra clase llamada \"Sensor_de_Temperatura\", que hereda de la primera. La clase \"Sensor\" es la clase padre o superior y la clase \"Sensor_de_Temperatura\" es la clase hija o inferior. Si est\u00e1s programando en la clase \"Sensor_de_Temperatura\" y necesitas acceder a un m\u00e9todo o propiedad de la clase \"Sensor\", puedes utilizar el puntero SUPER^ para referirte a la instancia de la clase \"Sensor\" a la que pertenece el objeto actual. Por ejemplo, si quieres acceder al m\u00e9todo \"obtener_valor()\" de la clase \"Sensor\", puedes hacerlo as\u00ed: SUPER^.obtener_valor(). Esto indica que quieres llamar al m\u00e9todo \"obtener_valor()\" de la instancia de la clase \"Sensor\" a la que pertenece el objeto actual.</p> <p>cada bloque de funciones que se deriva de otro bloque de funciones tiene acceso a un puntero llamado SUPER^.  Esto se puede usar para acceder a elementos (m\u00e9todos, propiedades, variables locales, etc.) desde el bloque de funciones principal.</p> <p>En lugar de copiar el c\u00f3digo del bloque de funciones principal al nuevo m\u00e9todo, el puntero SUPER^ se puede usar para llamar al m\u00e9todo desde el bloque de funciones  . Esto elimina la necesidad de copiar el c\u00f3digo.</p> <pre><code>SUPER^();                 // Llamada del cuerpo FB de la clase base.\nSUPER^.METH_DoIt();       // Llamada del m\u00e9todo METH_DoIt que se implementa en la clase base.\n</code></pre>"},{"location":"Clases%20y%20Objetos/SUPER%20pointer/#ejemplo","title":"Ejemplo:","text":"<ul> <li>Usando los punteros SUPER y THIS:</li> </ul> <p>Bloque de Funci\u00f3n -- FB_Base: <pre><code>FUNCTION_BLOCK FB_Base\nVAR_OUTPUT\nnCnt : INT;\nEND_VAR\n</code></pre> Metodo -- FB_Base.METH_DoIt: <pre><code>METHOD METH_DoIt : BOOL\nnCnt := -1;\n</code></pre> Metodo -- FB_Base.METH_DoAlso: <pre><code>METHOD METH_DoAlso : BOOL\nMETH_DoAlso := TRUE;\n</code></pre> Bloque de Funci\u00f3n -- FB_1: <pre><code>FUNCTION_BLOCK FB_1 EXTENDS FB_Base\nVAR_OUTPUT\nnBase: INT;\nEND_VAR\nTHIS^.METH_DoIt();      // llamada al metodo METH_DoIt del FB_1.\nTHIS^.METH_DoAlso();\n\nSUPER^.METH_DoIt();     // llamada al metodo METH_DoIt del FB_Base.\nSUPER^.METH_DoAlso();\nnBase := SUPER^.nCnt;\n</code></pre> Metodo -- FB_1.METH_DoIt: <pre><code>METHOD METH_DoIt : BOOL\nnCnt := 1111;    METH_DoIt := TRUE;\n</code></pre> Metodo -- FB_1.METH_DoAlso: <pre><code>METHOD METH_DoAlso : BOOL\nnCnt := 123;    METH_DoAlso := FALSE;\n</code></pre> Programa MAIN: <pre><code>PROGRAM MAIN\nVAR\nfbMyBase : FB_Base;\nfbMyFB_1 : FB_1;\nnTHIS    : INT;\nnBase    : INT;\nEND_VAR\nfbMyBase();\nnBase := fbmyBase.nCnt;\nfbMyFB_1();\nnTHIS := fbMyFB_1.nCnt;\n</code></pre></p>"},{"location":"Clases%20y%20Objetos/SUPER%20pointer/#links-super-pointer","title":"Links SUPER^ pointer:","text":"<ul> <li> <p>\ud83d\udd17 SUPER puntero Infosys Beckhoff</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, SUPER</p> </li> <li> <p>\ud83d\udd17 stefanhenneken.net,iec-61131-3-methods-properties-and-inheritance</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/SUPER%20pointer/#link-al-video-de-youtube-009","title":"Link al Video de Youtube 009:","text":"<ul> <li>\ud83d\udd17 009 - OOP IEC 61131-3 PLC -- Punteros THIS^ y SUPER^</li> </ul>"},{"location":"Clases%20y%20Objetos/THIS%20pointer/","title":"THIS puntero","text":""},{"location":"Clases%20y%20Objetos/THIS%20pointer/#this-puntero","title":"THIS^ puntero:","text":"<p>El puntero THIS^ se utiliza para referenciar la instancia actual de una clase en un programa orientado a objetos. En otras palabras, cuando se crea un objeto de una clase, el puntero THIS^ se utiliza para acceder a los atributos y m\u00e9todos de ese objeto espec\u00edfico. Por ejemplo, si tenemos una clase llamada \"Motor\" con un atributo \"velocidad\" y un m\u00e9todo \"acelerar\", al crear un objeto de la clase Motor, podemos utilizar el puntero THIS^ para hacer referencia a ese objeto y modificar su velocidad o acelerar.</p> <p>El puntero THIS^ est\u00e1 disponible para todos los bloques de funciones y apunta a la instancia de bloque de funciones actual.  Este puntero es necesario siempre que un m\u00e9todo contenga una variable local que oculte una variable en el bloque de funciones.</p> <p>Una declaraci\u00f3n de asignaci\u00f3n dentro del m\u00e9todo establece el valor de la variable local.  Si queremos que el m\u00e9todo establezca el valor de la variable local en el bloque de funciones, necesitamos usar el puntero THIS^ para acceder a \u00e9l.</p> <p>Al igual que con el puntero SUPER, el puntero THIS tambi\u00e9n debe estar siempre en may\u00fasculas.</p> <pre><code>THIS^.METH_DoIt();\n</code></pre>"},{"location":"Clases%20y%20Objetos/THIS%20pointer/#ejemplos","title":"Ejemplos:","text":"<ul> <li>La variable del bloque de funciones nVarB se establece aunque nVarB est\u00e1 oculta.</li> </ul> <pre><code>FUNCTION_BLOCK FB_A\nVAR_INPUT\nnVarA: INT;\nEND_VAR\n\nnVarA := 1;\n\nFUNCTION_BLOCK FB_B EXTENDS FB_A\nVAR_INPUT\nnVarB : INT := 0;\nEND_VAR\n\nnVarA := 11;\nnVarB := 2;\n\nMETHOD DoIt : BOOL\nVAR_INPUT\nEND_VAR\nVAR\nnVarB : INT;\nEND_VAR\n\nnVarB := 22; // Se establece la variable local nVarB.\nTHIS^.nVarB := 222; // La variable del bloque de funciones nVarB se establece aunque nVarB est\u00e1 oculta.\n\nPROGRAM MAIN\nVAR\nfbMyfbB : FB_B;\nEND_VAR\n\nfbMyfbB(nVarA:=0, nVarB:= 0);\nfbMyfbB.DoIt();\n</code></pre> <ul> <li>Una llamada de funci\u00f3n necesita la referencia a la propia instancia de FB.</li> </ul> <pre><code>FUNCTION F_FunA : INT\nVAR_INPUT\nfbMyFbA : FB_A;\nEND_VAR\n...;\n\nFUNCTION_BLOCK FB_A\nVAR_INPUT\nnVarA: INT;\nEND_VAR\n...;\n\nFUNCTION_BLOCK FB_B EXTENDS FB_A\nVAR_INPUT\nnVarB: INT := 0;\nEND_VAR\n\nnVarA := 11;\nnVarB := 2;\n\nMETHOD DoIt : BOOL\nVAR_INPUT\nEND_VAR\nVAR\nnVarB: INT;\nEND_VAR\n\nnVarB := 22;  //Se establece la variable local nVarB.\nF_FunA(fbMyFbA := THIS^);  //F_FunA es llamado via THIS^.\n\nPROGRAM MAIN\nVAR\nfbMyFbB: FB_B;\nEND_VAR\n\nfbMyFbB(nVarA:=0 , nVarB:= 0);\nfbMyFbB.DoIt();\n</code></pre>"},{"location":"Clases%20y%20Objetos/THIS%20pointer/#links-this-pointer","title":"Links THIS^ pointer:","text":"<ul> <li> <p>\ud83d\udd17 THIS puntero Infosys Beckhoff</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, THIS</p> </li> <li> <p>\ud83d\udd17 stefanhenneken.net,iec-61131-3-methods-properties-and-inheritance</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/THIS%20pointer/#link-al-video-de-youtube-009","title":"Link al Video de Youtube 009:","text":"<ul> <li>\ud83d\udd17 009 - OOP IEC 61131-3 PLC -- Punteros THIS^ y SUPER^</li> </ul>"},{"location":"Clases%20y%20Objetos/clases%20y%20objetos/","title":"Clases y Objetos","text":""},{"location":"Clases%20y%20Objetos/clases%20y%20objetos/#clases-y-objetos","title":"Clases y Objetos:","text":"<ul> <li>Una Clase es una plantilla.</li> <li>Un Objeto es la instancia de una Clase.</li> </ul> <pre><code>En este Ejemplo Nos encontramos la Clase Coche,\ny hemos instanciado esta Clase para tener los Objetos de Coches \nMercedes, Bmw y Audi...\n</code></pre>"},{"location":"Clases%20y%20Objetos/clases%20y%20objetos/#representacion-de-la-clase-coche-en-stl-oop-iec-61131-3","title":"Representacion de la Clase Coche en STL OOP IEC 61131-3","text":"<p><pre><code>FUNCTION_BLOCK Coche\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n    _Marca : STRING;\n    _Color : STRING;\n    accion : STRING;\nEND_VAR\n----------------------------------------------------------------\nMETHOD PUBLIC Acelerar\naccion := 'acelerar';\n----------------------------------------------------------------\nMETHOD PUBLIC Conducir\naccion := 'conducir';\n----------------------------------------------------------------\nMETHOD PUBLIC Frenar\naccion := 'frenar';\n----------------------------------------------------------------\nPROPERTY PUBLIC Color : STRING\nGet\n    Color := _Color;\nSet\n    _Color := Color;\n----------------------------------------------------------------\nPROPERTY PUBLIC Marca : STRING\nGet\n    Marca := _Marca;\nSet\n    _Marca := Marca;\n</code></pre> Instancia de la clase en los Objetos: Mercedes,Bmw y Audi y llamadas a sus metodos y propiedades... <pre><code>PROGRAM _01_Clase_y_Objetos\nVAR\n    // tenemos la Clase Coche y la instanciamos y obtenemos los Objetos: Mercedes, Bmw y Audi.\n    Mercedes : Coche;\n    Bmw : Coche;\n    Audi: Coche;\n\n    Color : STRING;\n    Marca : STRING;\n\n    Acelerar : BOOL;\n    Conducir:  BOOL;\n    Frenar  : BOOL; \nEND_VAR\n\n//Objeto Mercedes\n//llamadas a sus m\u00e9todos.\nIF Acelerar THEN\n    Mercedes.Acelerar();\n    Acelerar := FALSE;\nEND_IF\n\nIF Conducir THEN\n    Mercedes.Conducir();\n    Conducir := FALSE;\nEND_IF\n\nIF Frenar THEN\n    Mercedes.Frenar();\n    Frenar := FALSE;\nEND_IF\n\n//llamadas a sus propiedades.\nMercedes.Marca := 'Mercedes';\nMercedes.Color := 'Negro';\nColor := Mercedes.Color;\n</code></pre></p>"},{"location":"Clases%20y%20Objetos/clases%20y%20objetos/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 methods-properties-and-inheritance (stefanhenneken)</p> </li> <li> <p>\ud83d\udd17 Object Oriented Industrial Programming (OOIP) -- March 2021 CODESYS Tech Talk</p> </li> <li> <p>\ud83d\udd17 Clase de Programaci\u00f3n Orientada a Objetos en una hora ! C\u00f3mo crear tus entidades, herencia y m\u00e1s</p> </li> <li> <p>\ud83d\udd17 Object Oriented Programming (OOP) in Java Course</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/clases%20y%20objetos/#link-al-video-de-youtube-002","title":"Link al Video de Youtube 002:","text":"<ul> <li>\ud83d\udd17 002 - OOP IEC 61131-3 PLC -- Clase y Objeto</li> </ul>"},{"location":"Clases%20y%20Objetos/interface/","title":"Interface","text":""},{"location":"Clases%20y%20Objetos/interface/#interface","title":"Interface:","text":"<p>En la programaci\u00f3n orientada a objetos (OOP) en PLCs, una interfaz es un tipo de estructura que define un conjunto de m\u00e9todos y propiedades que una clase debe implementar. En otras palabras, una interfaz define un contrato entre diferentes partes del c\u00f3digo para asegurar que se cumplan ciertos requisitos y se mantenga una estructura coherente. En t\u00e9rminos pr\u00e1cticos, esto significa que cuando se crea una clase que implementa una interfaz, esa clase debe proporcionar los m\u00e9todos y propiedades definidos en la interfaz. Esto permite que diferentes clases compartan un conjunto com\u00fan de m\u00e9todos y propiedades y se comuniquen entre s\u00ed de manera coherente. Por ejemplo, si tienes una interfaz \"I_Sensor\" con los m\u00e9todos: \"LeerValor\",\"Calibrar\" y \"Descalibrar\" y las Propiedades: \"Temperatura\", \"Consigna\" y \"Calibrado\" cualquier clase que implemente esa interfaz debe proporcionar esos tres m\u00e9todos y las tres propiedades. Esto asegura que cualquier otra parte del c\u00f3digo que trabaje con esa clase pueda confiar en que esos m\u00e9todos y propiedades estar\u00e1n disponibles.</p> <p></p> <ul> <li>Una interfaz es una clase que contiene m\u00e9todos y propiedades sin implementaci\u00f3n. </li> <li>La interfaz se puede implementar en cualquier clase, pero esa clase debe implementar todos sus m\u00e9todos. y propiedades.</li> <li>Si bien la herencia es una relaci\u00f3n \"es un\", las interfaces se pueden describir como \"se comporta como\" o \u201ctiene una\u201d relaci\u00f3n.</li> <li>Las interfaces son objetos que permiten que varias clases diferentes tengan algo en com\u00fan con menos dependencias. Las clases y los bloques de funciones pueden implementar varias interfaces diferentes. Uno puede pensar en los m\u00e9todos y propiedades de la interfaz como acciones que significan cosas diferentes dependiendo de qui\u00e9n los est\u00e9 ejecutando. Por ejemplo, la palabra \"Correr\" significa \"mover a una velocidad m\u00e1s r\u00e1pido que un paseo\u201d para un ser humano, pero significa \u201cejecutar\u201d para las computadoras.</li> <li>Las clases o bloques de funciones que no comparten similitudes pueden implementar la misma interfaz. En este caso, la implementaci\u00f3n de los m\u00e9todos en cada clase puede ser totalmente diferente. Esto abre muchos enfoques de programaci\u00f3n poderosos:</li> <li>Las POU pueden llamar a una interfaz para ejecutar un m\u00e9todo o acceder a una propiedad, sin saber cu\u00e1l clase o FB con el que se trata o c\u00f3mo va a ejecutar la operaci\u00f3n.  La interfaz luego apunta a una clase o bloque de funci\u00f3n que implementa la interfaz y la operaci\u00f3n que es ejecutado.</li> <li>Los programadores pueden crear cajas de interruptores f\u00e1cilmente personalizables usando polimorfismo.</li> </ul>"},{"location":"Clases%20y%20Objetos/interface/#links-interface","title":"Links Interface:","text":"<ul> <li> <p>\ud83d\udd17 Codesys Comando 'Implementar interfaces'</p> </li> <li> <p>\ud83d\udd17 Codesys_3.5.13.0 Objeto Interface</p> </li> <li> <p>\ud83d\udd17 Codesys_3.5.14.0 Objeto Interface</p> </li> <li> <p>\ud83d\udd17 Codesys Implementando Interfaces</p> </li> <li> <p>\ud83d\udd17 Beckhoff Objeto Interface</p> </li> <li> <p>\ud83d\udd17 Beckhoff Implementando Interfaces</p> </li> <li> <p>\ud83d\udd17 Extender Interfaces, Infosys Beckhoff</p> </li> <li> <p>\ud83d\udd17 TC09.Beckhoff TwinCAT3 Function Block-Part4 Interface.JP</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/interface/#link-al-video-de-youtube-010","title":"Link al Video de Youtube 010:","text":"<ul> <li>\ud83d\udd17 010 - OOP IEC 61131-3 PLC -- Interface</li> </ul>"},{"location":"Clases%20y%20Objetos/metodo/","title":"Metodo","text":""},{"location":"Clases%20y%20Objetos/metodo/#method","title":"METHOD:","text":"<p>Los M\u00e9todos dividen la clase (bloque de funciones) en funciones m\u00e1s peque\u00f1as que se pueden ejecutar en llamada. Solo trabajar\u00e1n con los datos que necesitan e ignorar\u00e1n cualquier dato redundante que puede existir en un determinado bloque de funciones.</p> <p>Los m\u00e9todos pueden acceder y manipular las variables internas de la clase principal, pero tambi\u00e9n pueden usar variables propias a las que la clase principal no puede acceder (a menos que sean de salida la variable).</p> <p>Adem\u00e1s, los m\u00e9todos son una forma mucho m\u00e1s eficiente de ejecutar un programa porque, al dividir una funci\u00f3n en varios m\u00e9todos, el usuario evita ejecutar todo el POU cada vez, ejecutar solo peque\u00f1as porciones de c\u00f3digo siempre que sea necesario llamarlas. </p> <p>Esto es un muy buena manera de evitar errores y corrupci\u00f3n de datos. Los m\u00e9todos tambi\u00e9n tienen un nombre, lo que significa que estas porciones de c\u00f3digo se pueden identificar por su prop\u00f3sito en lugar de las variables que manipulan, mejorando as\u00ed la lectura de c\u00f3digo, comprensi\u00f3n y la soluci\u00f3n de problemas.</p> <p>La abstracci\u00f3n juega un papel importante aqu\u00ed, si los programadores desean implementar el c\u00f3digo,  solo necesitan llamar al m\u00e9todo.</p> <p>La soluci\u00f3n de problemas tambi\u00e9n se convierte en m\u00e1s simple: entonces el programador no necesita buscar cada instancia del c\u00f3digo, solo necesitan verificar el m\u00e9todo correspondiente. A diferencia de la clase base, los m\u00e9todos usan la memoria temporal del controlador: los datos son vol\u00e1tiles, ya que las variables solo mantendr\u00e1n sus valores mientras se ejecuta el m\u00e9todo. Si se suponen valores que deben mantenerse entre ciclos de ejecuci\u00f3n, entonces la variable debe almacenarse en la clase base o en alg\u00fan otro lugar que retendr\u00e1 los valores de un ciclo al otro (como la  lista de variables globales -- GVL), o tambi\u00e9n se puede utilizar la variable de tipo VAR_INST.</p> <p>Por lo tanto, una declaraci\u00f3n de M\u00e9todo tiene la siguiente estructura: <pre><code>METHOD &lt;Access specifier&gt; &lt;Name&gt; : &lt;Datatype return value&gt;\n</code></pre> No es obligatorio que un M\u00e9todo deba devolver un valor...</p>"},{"location":"Clases%20y%20Objetos/metodo/#ejemplo-de-declaracion-de-method","title":"Ejemplo de declaraci\u00f3n de METHOD:","text":"<pre><code>METHOD Method1 : BOOL\nVAR_INPUT\nnIn1  : INT;\nbIn2  : BOOL;\nEND_VAR\nVAR_OUTPUT\nfOut1 : REAL;\nsOut2 : STRING;\nEND_VAR\n</code></pre>"},{"location":"Clases%20y%20Objetos/metodo/#links-del-objeto-metodo","title":"Links del Objeto Metodo:","text":"<ul> <li> <p>\ud83d\udd17 Documentaci\u00f3n Codesys del Objeto m\u00e9todo</p> </li> <li> <p>\ud83d\udd17 Documentaci\u00f3n de Beckhoff del Objeto m\u00e9todo</p> </li> <li> <p>\ud83d\udd17 TC08.Beckhoff TwinCAT3 Function Block-Part3 Method.JP</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/metodo/#link-al-video-de-youtube-005","title":"Link al Video de Youtube 005:","text":"<ul> <li>\ud83d\udd17 005 - OOP IEC 61131-3 PLC -- Objeto Metodo</li> </ul>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/","title":"puntero y referencia","text":""},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#puntero-y-referencia","title":"Puntero y Referencia:","text":"<p>En la programaci\u00f3n orientada a objetos (OOP) en PLC IEC 61131-3, los punteros y las referencias son dos conceptos importantes que se utilizan para acceder a los datos y m\u00e9todos de un objeto.  Un puntero es una variable que almacena la direcci\u00f3n de memoria de otra variable.  Una referencia es una variable que se utiliza para acceder a otra variable sin tener que conocer su direcci\u00f3n de memoria.</p>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#que-es-un-puntero","title":". \u00bfQu\u00e9 es un puntero?","text":"<ul> <li>Es un dato que apunta o se\u00f1ala hacia una direcci\u00f3n de memoria.</li> <li>Es una variable que contiene la direcci\u00f3n de memoria donde \u201cvive\u201d la variable.</li> <li>Con el empleo de punteros se accede a la memoria de forma directa,por lo que es una buena t\u00e9cnica para reducir el tiempo de ejecuci\u00f3n de un programa y otras muchas m\u00e1s funcionalidades.</li> </ul>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#tipos-de-punteros","title":". Tipos de Punteros:","text":"<ul> <li>Hay un tipo de puntero para cada tipo de dato, programa, Function Block, funciones, etc. </li> <li>Seg\u00fan sea el \u201cobjeto\u201d al que se desea acceder se necesita un puntero de un tipo u otro.</li> </ul>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#declaracion-de-punteros","title":". Declaraci\u00f3n de punteros:","text":"<p>El compilador necesita conocer todos los punteros que se vayan a emplear en el proyecto, por lo que hay que declararlos, como cualquier otra variable.  En el c\u00f3digo se muestra el script necesario para la declaraci\u00f3n de varios tipos de punteros:</p> <pre><code>// Un puntero no deja de ser una variable, la diferencia est\u00e1 en que su contenido no es un valor determinado sino que es la direcci\u00f3n \n// de memoria donde se ubica la variable de la que se quiere leer o escribir su valor. Y al igual que hay que declarar todas las\n// variables del tipo correspondiente. tambi\u00e9n hay que declarar todas las variables -punteros- que contendr\u00e1n esas direcciones de \n// memoria y su correspondiente tipo.\nVAR\nstTest1 : stTipo1; //Declara una estructura de datos del tipo stTipo1.\n\npin01 : POINTER TO INT; //Declara un puntero para acceder a variables del tipo INT.\nps20  : POINTER TO STRING[20]; //Declara un puntero para acceder a variables del tipo STRING de 20 caracteres.\npa20 : POINTER TO ARRAY [1..20] OF INT; //Declara un puntero para acceder a variables del tipo ARRAY de 20 elementos del tipo INT.\npDword : POINTER TO DWORD; //Declara un puntero para acceder a variables del tipo DWORD.\npast1  : POINTER TO stTipo1; //Declara un puntero para acceder a variables del tipo stTipo1.\npReal  : POINTER TO REAL; //Declara un puntero para acceder a variables del tipo REAL.\nEND_VAR\n</code></pre>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#como-saber-que-direccion-asignar-al-puntero","title":". Como saber qu\u00e9 direcci\u00f3n asignar al puntero:","text":"<ul> <li>Para poder acceder a una variable mediante un puntero se necesita conocer su direcci\u00f3n de memoria,  Para ello se dispone de un operador llamado ADR que asigna la direcci\u00f3n de la variable deseada, al puntero.</li> <li>Es conveniente verificar que el valor del puntero no es cero, antes de utilizarlo. Por otra parte, para poder leer / escribir el valor de la variable, a la que se\u00f1ala el puntero,  se dispone del operador de contenido ^. Cuando se hace referencia al contenido, de la direcci\u00f3n de memoria apuntada, se habla de desreferenciar el puntero. En el siguiente c\u00f3digo se muestra un ejemplo:</li> </ul> <pre><code>PROGRAM SR_Main_02\nVAR\nin01    : INT; //Declaraci\u00f3n de la variable in01 de tipo entero.\nin02    : INT := 123; //Declaraci\u00f3n e inicializaci\u00f3n de la variable in02 de tipo entero.\nin03    : INT; //Declaraci\u00f3n de la variable in03 de tipo entero.\n\npint    : POINTER TO INT; //Declaraci\u00f3n de un puntero para acceder a variables del tipo entero.\nEND_VAR\n\n// Ejemplo de uso b\u00e1sico de los operadores ADR y del operador de contenido ^\n// Se muestra como asignar a un puntero la direcci\u00f3n de memoria de una variable y como leer/escribir\n// as\u00ed como un ejemplo de acceso a variables locales de otros programas.\n\npint := ADR(in01); //Asignamos al puntero la direcci\u00f3n de memoria donde se ubica la variable in01.\npint^ := 44;     //A la posici\u00f3n de memoria indicada por el puntero, le asignamos el valor 44\n//Por tanto a la variable in01 se le ha escrito el valor 44.\n\nin02 := in01; // in02 ser\u00e1 igual a 44.\n\npint := ADR(in02); //Cambiamos la direcci\u00f3n para acceder a la direcci\u00f3n de la variable in02.\nin03 := pint^; // in03 tomara el valor del contenido de la posici\u00f3n de memoria contenida en el\n// que hemos asignado la direcci\u00f3n de in02, por tanto in03= 123.\n\npint := ADR(SR_Main_01.inLocalAway); //Cargamos la direcci\u00f3n de memoria de una variable local de \n// otro programa, la que ser\u00eda inaccesible por otros medios.\npint^ := 240 ; // La varible local del programa SR_Main_01.inLocalAway tomar\u00e1 el valor 240                                                \n</code></pre>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#que-es-un-acceso-indirecto","title":". \u00bfQu\u00e9 es un acceso indirecto?","text":"<p>Lo primero, decir que no tiene nada que ver con un puntero. Un acceso indirecto permite elegir un n\u00famero de elemento dentro de un array, hay una variable, llamada \u00edndice, que contiene el n\u00famero del elemento del array al que se desea acceder. En este caso no se puede acceder a ninguna otra variable m\u00e1s all\u00e1 de los elementos del array, insisto en que no tiene nada que ver con los punteros. Con un puntero se puede acceder a cualquier dato u objeto que est\u00e9 en la memoria del control. Con un acceso indirecto solo se puede acceder a los elementos de un array. En el siguiente c\u00f3digo se muestra unos ejemplos de acceso indirecto a un array:</p> <p><pre><code>PROGRAM SR_Main_01\nVAR\naR20: ARRAY[1..20] OF REAL; //Declara un array de 20 elementos del tipo REAL.\ninIndex: INT; //Declara la variable de indice del array para el acceso indirecto\nxNewVal: BOOL; //Indica que hay una nueva lectura del sensor de fuerza.\nrFuerza: REAL; //Valor de fuerza del sensor.\nEND_VAR\n\n// Ejemplo01: Se asigna valores del 1 al 20 a cada elemento del array mediante un bucle.\nFOR inIndex:=1 TO 20 BY 1 DO  // Se empieza por el valor de la variable indice a 1, hasta 20\naR20[inIndex] := inIndex; // Al elemento aR20[inIndex] se le asigna el valor de inIndex\nEND_FOR;                      // Se incrementa inIndex y se repite el proceso.\n\n// Ejemplo02: Creamos un FIFO en el que guardamos un valor anal\u00f3gico de fuera a cada impulso de la se\u00f1al xNewVal.\nIF xNewVal THEN                // Si hay un nuevo valor de fuerza realizamos el codigo.\nxNewVal := FALSE;          // Reset de la se\u00f1al xNewVal.\n\nFOR inIndex:=20 TO 2 BY -1 DO // Variable indice a 20, hasta 2.\naR20[inIndex] := aR20[inIndex-1]; //Desplazamiento de los valores en el FIFO ---&gt;\nEND_FOR;                             // Se decrementa inIndex y se repite el proceso.\n\naR20[1] := rFuerza; // Entrada del valor de fuerza en el primer elemento del FIFO.\nEND_IF\n</code></pre> A este mismo array se puede acceder empleando un puntero, como se ver\u00e1 m\u00e1s adelante, lo que resulta m\u00e1s r\u00e1pido en tiempo de ejecuci\u00f3n,  pero no tan claro para quien no suele usar los punteros. </p>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#acceso-a-una-estructura-de-datos-mediante-punteros","title":". Acceso a una estructura de datos mediante punteros:","text":"<p>El proceso es el mismo que ya se ha visto para acceder a una variable del tipo INT, pero se tendr\u00e1 que declarar un puntero del tipo adecuado, que coincida con el tipo de estructura a la que se desea acceder, ve\u00e1moslo en el siguiente c\u00f3digo:</p> <pre><code>PROGRAM SR_Main_03\nVAR\nstMotor_01 : stMotorCtrl; // Estructura de control del motor 1\nstMotor_02 : stMotorCtrl; // Estructura de control del motor 2\nstMotor_03 : stMotorCtrl; // Estructura de control del motor 3\npstMotorCtrl : POINTER TO stMotorCtrl; // Puntero para acceder a estructuras del tipo stMotorCtrl.\nxMarcha : BOOL; // Pulsador marcha motores.\nEND_VAR\n\n// Ejemplo b\u00e1sico de como acceder a estructuras de datos mediante punteros.\n// La estructura de datos empleada es una llamada a stMotorCtrl, que coincide un bit de marcha, otro de paro y\n// valores de velocidad en Rpms y tiempo de aceleraci\u00f3n/deceleraci\u00f3n.\n\n// Asignamos valores a la estructura para el control del motor 1.\n\nstMotor_01.rTpoAcelDecel := 5.4; // Tiempo para acelerar/decelerar hasta alcanazar la velocidad.\nstMotor_01.rVelRpm := 1436.2; // Velocidad en RPM.\nstMotor_01.xMotorOff := TRUE; // Bit de paro ON.\nstMotor_01.xMotorOn := FALSE   ; // Bit de marcha OFF.\n\npstMotorCtrl := ADR(stMotor_01); // Cargamos la direcci\u00f3n de memoria de la estructura del motor 1\nstMotor_02 := pstMotorCtrl^; // Copia el contenido de la zona de memoria apuntada a la\n// estructura del motor 2, en este caso el resultado es el mismo\n// que se obtendr\u00eda con stMotor_02:= stMotor_01;\n\nstMotor_03 := stMotor_02; // Copia los mismos valores al motor 3;\n\nIF xMarcha THEN         // Si se pulsa marcha m\u00e1quina\npstMotorCtrl^.xMotorOn := TRUE; // Se activa el bit de marcha al que apunta el puntero (stMotor_01).\npstMotorCtrl^.xMotorOff := FALSE; // Se desactiva el bit de paro al que apunta el puntero (stMotor_01)\nEND_IF\n</code></pre>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#acceso-a-un-array-mediante-punteros","title":". Acceso a un array mediante punteros:","text":"<p>El proceso es el mismo que ya se ha visto para acceder a una variable del tipo INT, pero se tendr\u00e1 que declarar un puntero a un array del n\u00famero de elementos y tipo de datos adecuados,  ve\u00e1moslo en el siguiente c\u00f3digo:</p> <pre><code>PROGRAM SR_Main_03\nVAR\naintFIFO    : ARRAY[1..20] OF INT; // Array de 20 enteros.\naintFIFO2   : ARRAY[1..20] OF INT; // Array de 20 enteros.\npaint       : POINTER TO ARRAY[1..20] OF INT; // Puntero al array.\npint        : POINTER TO INT; // Puntero a un entero.\nEND_VAR\n\n// Ejemplo basico de como acceder a arrays mediante punteros:\npaint := ADR(aintFIFO); // _Asignamos la direcci\u00f3n del array al puntero.\npaint^[3] := 4; // Dentro del array podemos acceder a un elemento en concreto\naintFIFO2 := paint^; // O copiar el array apuntado entero, sobre otro array\npint := paint + (4 * SIZEOF (INT)); // Tambien se puede crear un puntero a un INT para acceder a uno de los\n// elementos del array. Tomamos la direcci\u00f3n inicial del array y le\n// sumampos un offeset de tantos bytes como se necesitan para el tipo de \n// datos INT y lo multiplicamos por el indice del array al que queremos\n// acceder. SIZEOF (TYPE) retorna el n\u00famero de bytes seg\u00fan el tipo de datos.\n\npint^ := 5;                         // Asignamos el valor de 5, aintFIFO[5]:=5 ser\u00eda lo mismo. \n</code></pre>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#acceso-a-datos-por-referencias","title":". Acceso a datos por referencias:","text":"<p>El acceso por referencia no deja de ser un acceso por puntero, pero en este caso la direcci\u00f3n de una referencia es la misma que la del objeto al que apunta. Un puntero tiene su propia direcci\u00f3n y esta contiene la direcci\u00f3n del objeto al que se quiere hacer referencia.  Las referencias se inicializan al principio del programa y no pueden cambiar durante su ejecuci\u00f3n.  A un puntero se le puede cambiar su direcci\u00f3n tanto como sea necesario durante la ejecuci\u00f3n del programa. Otra forma de entender las referencias es como si fuesen otra manera de referirse a un mismo objeto/variable, como si fuese un alias. Frente a los punteros, las referencias presentan las siguientes ventajas:</p> <ul> <li>1) Facilidad de uso.</li> <li>2) Sintaxis m\u00e1s sencilla a la hora de pasar par\u00e1metros a funciones.</li> <li>3) Minimiza errores en la escritura del c\u00f3digo.</li> </ul> <p>El resumen de todo esto, que se puede prestar a mucha confusi\u00f3n, es que, como se ver\u00e1 m\u00e1s adelante, el gran valor de las referencias es a la hora de pasar grandes  cantidades de datos como par\u00e1metros de entrada a funciones.</p>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#diversas-formas-de-pase-de-parametros-a-funciones","title":". Diversas formas de pase de par\u00e1metros a funciones:","text":"<p>Normalmente una funci\u00f3n realiza unas operaciones con unos par\u00e1metros de entrada y retorna un valor - o varios - como resultado.  En el ejemplo que veremos seguidamente se trata de una funci\u00f3n para calcular el \u00e1rea de un rect\u00e1ngulo, a la que le pasaremos los valores del lado A y el lado B para que nos retorne el resultado del \u00e1rea. </p> <p>Lo primero definiremos un tipo de dato [stRect\u00e1ngulo] que contendr\u00e1 el lado A, el B y el \u00e1rea. </p> <p>Crearemos tres rect\u00e1ngulos, [stRectangulo01], [stRectangulo02] y [stRectangulo03]. </p> <p>Junto con tres variantes de la funci\u00f3n para el c\u00e1lculo del \u00e1rea:</p> <ul> <li>[Fc_AreaCalcVal] - pase por valores - </li> <li>[Fc_AreaCalcPoint] - pase por puntero - </li> <li>[Fc_AreaCalcRef] - pase por referencia \u2013</li> </ul> <p>A continuaci\u00f3n, el c\u00f3digo de las tres funciones:</p>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#pase-de-valores","title":"Pase de valores:","text":"<pre><code>// Funci\u00f3n para calcular el area de un Rectangulo, pasando los valores de los lados del Rectangulo\n// la funci\u00f3n retorna el resultado del area calculado\n\nFUNCTION Fc_AreaCalcVal : REAL // La funci\u00f3n retona un n\u00famero real\nVAR_INPUT\ni_rASide    : REAL; // Par\u00e1metro de entrada que contiene el lado A del rectangulo.\ni_rBSide    : REAL; // Par\u00e1metro de entrada que contiene el lado B del rectangulo.\nEND_VAR\n\nFc_AreaCalcVal := i_rASide * i_rBSide; // Retorna el resultado de multiplicar el lado A por el lado B.\n</code></pre>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#pase-por-puntero","title":"Pase por puntero:","text":"<pre><code>// Funci\u00f3n para calcular el area de un Rectangulo, con los valores contenidos en una estructura de datos del tipo stRectangulo\n// La estructura se pasa mediante un puntero a la estructura stRectangulo deseada y la funci\u00f3n retorna el resultado a la \n// misma estructura.\n\nFUNCTION Fc_AreaCalcPoint : REAL\nVAR_INPUT\ni_ptstRect : POINTER TO st_Rectangulo; // Puntero de entrada con la direcci\u00f3n de la estructura.\nEND_VAR\n\n// El valor del area, de la estructura indicada por la direcci\u00f3n del puntero es igual al\n// valor del lado A de la estructura indicada por la direcci\u00f3n del puntero por\n// el valor del lado B de la estructura indicada por la direcci\u00f3n del puntero\ni_ptstRect^.rArea := i_ptstRect^.rASide * i_ptstRect^.rBSide;\n</code></pre>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#pase-por-referencia","title":"Pase por Referencia:","text":"<pre><code>// Funci\u00f3n para calcular el area de un Rectangulo, con los valores contenidos en una estructura de datos del tipo stRectangulo\n// La estructura se pasa por referencia.\n\nFUNCTION Fc_AreaCalcRef : REAL\nVAR_INPUT\ni_Ref : REFERENCE TO st_Rectangulo;\nEND_VAR\n\ni_Ref.rArea := i_Ref.rASide * i_Ref.rBSide;\n</code></pre>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#ejemplo-de-codigo-de-llamadas-a-las-funciones","title":"Ejemplo de c\u00f3digo de llamadas a las funciones:","text":"<p><pre><code>PROGRAM SR_Main_01\nVAR\ninLocalAway : INT; // Variable integer local de SR_Main_01 para ser accedida externamente\nstRectangulo1 : st_Rectangulo; // Estructura que contiene los datos del rectangulo1 A, B y su area\nstRectangulo2 : st_Rectangulo; // Estructura que contiene los datos del rectangulo2 A, B y su area\nstRectangulo3 : st_Rectangulo; // Estructura que contiene los datos del rectangulo3 A, B y su area\n\nrefRectangulo : REFERENCE TO st_Rectangulo := stRectangulo3; // Hace Referencia a stRectangulo3   \nEND_VAR\n\n// Asignaci\u00f3n de valores a los lados de los tres rect\u00e1ngulos.\n\n// Asignaci\u00f3n de valores de los lados del rect\u00e1ngulo 1\nstRectangulo1.rAside := 44; //Valor del lado A.\nstRectangulo1.rBside := 32; //Valor del lado B.\n\n// Asignaci\u00f3n de valores de los lados del rect\u00e1ngulo 2\nstRectangulo2.rAside := 12.8; //Valor del lado A.\nstRectangulo2.rBside := 320.4; //Valor del lado B.\n\n// Asignaci\u00f3n de valores de los lados del rect\u00e1ngulo 3\nstRectangulo3.rAside := 1024.2; //Valor del lado A.\nstRectangulo3.rBside := 2048.4; //Valor del lado B.\n\n// C\u00e1lculo del \u00e1rea del rect\u00e1ngulo pasando valores a la funci\u00f3n\nstRectangulo1.rArea := Fc_AreaCalcVal(i_rAside:=stRectangulo1.rAside, i_rBside:= stRectangulo1.rBside);\n\n// C\u00e1lculo del \u00e1rea del rect\u00e1ngulo pasando un puntero a la funci\u00f3n\nFc_AreaCalcPoint(ADR(stRectangulo2));\n\n// C\u00e1lculo del \u00e1rea del rect\u00e1ngulo pasando una referencia a la funci\u00f3n\nFc_AreaCalcRef(refRectangulo);\n</code></pre> En este caso puede que las diferencias pueden parecer insignificantes, puesto que la cantidad de datos que se le pasan a la funci\u00f3n son pocos. Pero seguidamente veremos un ejemplo con mayor n\u00famero de par\u00e1metros de entrada para poder apreciar las ventajas del pase de par\u00e1metros por, especialmente, referencia y tambi\u00e9n por puntero.</p>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#caso-de-pase-de-grandes-cantidades-de-datos-a-funciones","title":".Caso de pase de grandes cantidades de datos a funciones:","text":"<p>Cuando se precisa pasar estructuras con gran cantidad de datos a funciones \u00f3 a FB\u00b4s, el pase de par\u00e1metros por valores no es el m\u00e9todo m\u00e1s adecuado puesto que se requieren gran cantidad de par\u00e1metros de entrada, cada par\u00e1metro implica crear una nueva variable local de la funci\u00f3n, o del FB, lo que supone gasto de memoria y tiempo de ejecuci\u00f3n en copiar los datos. Caso de estructuras de datos de varios Kbytes, o arrays de centenares o miles de elementos, este m\u00e9todo es impensable.  En el caso de tener que pasar grandes cantidades de datos, la soluci\u00f3n es el empleo de punteros, o mejor a\u00fan, el pase de datos por referencia.  Seguidamente se muestra un ejemplo de una funci\u00f3n para calcular el valor promedio de un array de 20 elementos, pasando los valores a la funci\u00f3n y  pasando los valores mediante una referencia.</p>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#codigo-de-la-funcion-fc_averagevalues-para-pase-de-valores","title":"C\u00f3digo de la funci\u00f3n Fc_AverageValues para pase de valores:","text":"<pre><code>// Esta funci\u00f3n calcula la media de un buffer de 20 elementos. Solo a modo de ejemplo comparativo\n// no ser\u00eda una forma muy adecuada de hacerlo as\u00ed\n\nFUNCTION Fc_AverageValues : REAL\nVAR_INPUT\ni_REALV1  : REAL; //Valor posici\u00f3n 1\ni_REALV2  : REAL; //Valor posici\u00f3n 2\ni_REALV3  : REAL; //Valor posici\u00f3n 3\ni_REALV4  : REAL; //Valor posici\u00f3n 4\ni_REALV5  : REAL; //Valor posici\u00f3n 5\ni_REALV6  : REAL; //Valor posici\u00f3n 6\ni_REALV7  : REAL; //Valor posici\u00f3n 7\ni_REALV8  : REAL; //Valor posici\u00f3n 8\ni_REALV9  : REAL; //Valor posici\u00f3n 9\ni_REALV10 : REAL; //Valor posici\u00f3n 10\ni_REALV11 : REAL; //Valor posici\u00f3n 11\ni_REALV12 : REAL; //Valor posici\u00f3n 12\ni_REALV13 : REAL; //Valor posici\u00f3n 13\ni_REALV14 : REAL; //Valor posici\u00f3n 14\ni_REALV15 : REAL; //Valor posici\u00f3n 15\ni_REALV16 : REAL; //Valor posici\u00f3n 16\ni_REALV17 : REAL; //Valor posici\u00f3n 17\ni_REALV18 : REAL; //Valor posici\u00f3n 18\ni_REALV19 : REAL; //Valor posici\u00f3n 19\ni_REALV20 : REAL; //Valor posici\u00f3n 20\nEND_VAR\n\n//Retorna la suma de todos los valores dividida del n\u00famero de valores que son 20.\n\nFc_AverageValues := (i_REALV1 + i_REALV2 + i_REALV3 + i_REALV4 + i_REALV5 + i_REALV6 + i_REALV7 + i_REALV8 + i_REALV9 + i_REALV10 + i_REALV11 + i_REALV12 + i_REALV13 + i_REALV14 + i_REALV15 + i_REALV16 + i_REALV17 + i_REALV18 + i_REALV19 + i_REALV20) / 20.0 ;\n</code></pre>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#codigo-de-la-funcion-fc_averagereferencia-para-pase-por-referencia","title":"C\u00f3digo de la funci\u00f3n Fc_AverageReferencia para pase por referencia:","text":"<pre><code>// Esta funci\u00f3n calcula la media de un buffer de 20 elementos. Solo a modo de ejemplo comparativo\n// pasando valores por referencia.\n\nFUNCTION Fc_AverageReferencia : REAL\n\nVAR_INPUT\ni_Ref : REFERENCE TO ARRAY[1..20] OF REAL;\nEND_VAR\nVAR\nintIdx : INT;      // Variable indice para el bucle.\nrVAcum : REAL:=0; // Valor acumulado.\nEND_VAR\n\n// Retorna la suma de todos los valores divida del n\u00famero de valores que son 20.\n\nFOR intIdx:=1 TO 20 BY 1 DO\nrVAcum := rVAcum + i_Ref[intIdx];\nEND_FOR;\nFc_AverageReferencia := rVAcum / 20.0;\n</code></pre>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#codigo-de-ejemplo-de-llamada-a-ambas-funciones","title":"C\u00f3digo de ejemplo de llamada a ambas funciones:","text":"<p><pre><code>PROGRAM SR_Main_04\nVAR\narFIFO  : ARRAY[1..20] OF REAL; // FIFO con los valores de fuerza registrados.\nintIdx  : INT;                  // Variable de indice.\nrIncAng : REAL;                 // Valor de incremento angular para generaci\u00f3n de senoide.\nrValAng : REAL;                 // Valor actual de angulo.\nrValSin : REAL;                 // Amplitud de la senoide superpuesta.\nrVMed   : REAL;                 // Resultado del c\u00e1lculo.\n\nrefFIFO : REFERENCE TO ARRAY[1..20] OF REAL := arFIFO; // Crea una referencia y la asigna a arFIFO\nrMedRef : REAL;           // Resultado del c\u00e1lculo para el ejemplo de pase de valores por Ref.\nEND_VAR\n\n// Ejemplo de como realizar el c\u00e1lculo del valor medio de las lecturas de fuerza contenidas en arFIFO\n// mediante la funci\u00f3n Fc_AverageValues (Pase de par\u00e1metros por valores) y Fc_AverageReferencia (Pase de\n// par\u00e1metros por referencia)\n// Lo que se pretende es ver las ventajas del pase por referencia\n\n// Asignaci\u00f3n de valores para llenar el FIFO a efectos de tener algunos valores para el c\u00e1lculo de la media\n// al valor 124 le superpone una variaci\u00f3n senoidal de amplitud 6\n\nrIncAng := (2 * 3.14159) / 20.0; // 2 * PI Radianes dividido entre 20 puntos.\nrValAng := 0.0;                   // Valor inicial del angulo.\n\nFOR intIdx :=1 TO 20 BY 1 DO\nrValSin := SIN(rValAng) * 6;         // Valor del seno para una amplitud de 6\narFIFO[intIdx] := 124.0 + rValSin;  // A un nivel de 124.0 se superpone un seno de amplitud 6.\nrValAng := rValAng + rIncAng;       // Pr\u00f3ximo valor angular. \nEND_FOR;\n\n// Con el FIFO de valores llamaremos a la funci\u00f3n para el c\u00e1lculo de la media pasando valores.\n// Lo que no ser\u00eda para nada adecuado por tratarse de muchos par\u00e1metros.\n\nrVMed:= Fc_AverageValues( i_REALV1  := arFIFO[1],\ni_REALV2  := arFIFO[2],\ni_REALV3  := arFIFO[3],\ni_REALV4  := arFIFO[4], i_REALV5  := arFIFO[5],\ni_REALV6  := arFIFO[6], i_REALV7  := arFIFO[7],\ni_REALV8  := arFIFO[8],\ni_REALV9  := arFIFO[9],\ni_REALV10 := arFIFO[10],\ni_REALV11 := arFIFO[11],\ni_REALV12 := arFIFO[12],\ni_REALV13 := arFIFO[13],\ni_REALV14 := arFIFO[14],\ni_REALV15 := arFIFO[15],\ni_REALV16 := arFIFO[16],\ni_REALV17 := arFIFO[17],\ni_REALV18 := arFIFO[18],\ni_REALV19 := arFIFO[19],\ni_REALV20 := arFIFO[20]);\n\n// Con el FIFO lleno de valores llamaremos a la funci\u00f3n para el c\u00e1lculo de la media pasando valores por referencia\n// para ver lo sencillo que resulta en este caso.\n\nrMedRef := Fc_AverageReferencia(i_Ref:=refFIFO);\n</code></pre> Claramente la llamada a la funci\u00f3n pasando los valores por referencia es la mejor. Y en este ejemplo se ha supuesto un ejemplo con solo 20 datos de entrada, pero lo normal es encontrar aplicaciones con estructuras de datos de varios Kbytes.</p> <ul> <li>Un puntero de tipo T apunta a un objeto de tipo T (T = tipo de datos b\u00e1sico o definido por el usuario)</li> <li>Un puntero contiene la direcci\u00f3n del objeto al que apunta.</li> <li>La operaci\u00f3n fundamental con un puntero se llama \"desreferenciar\". La desreferenciaci\u00f3n en CODESYS se realiza con el s\u00edmbolo \"^\"</li> <li>Un puntero puede apuntar a un objeto diferente en un momento diferente.</li> <li>Antes de desreferenciar un puntero y asignarle un valor, siempre debe verificar si un puntero apunta a un objeto. (puntero = 0)?</li> <li>Una referencia del tipo T \"apunta\" a un objeto del tipo T (T = tipo de datos b\u00e1sico o definido por el usuario).</li> <li>Una referencia debe ser inicializada con un objeto y su \"apuntando\" a este objeto a trav\u00e9s del programa.</li> <li>Una referencia no debe ser desreferenciada como un puntero y puede usarse con la misma sintaxis que el objeto.</li> <li>Otra palabra de referencia es \"Alias\" (otro nombre) un seud\u00f3nimo para el objeto.</li> <li>La referencia no tiene direcci\u00f3n propia y un puntero s\u00ed. La direcci\u00f3n de la referencia es la misma que la del objeto \"puntiagudo\".</li> <li>No hay referencia 0, por lo que nunca debe llamar a la referencia si no est\u00e1 inicializada.</li> <li>Debe verificar si tiene una referencia v\u00e1lida con la palabra clave integrada CODESYS \"__ISVALIDREF\".</li> </ul> <p>El mejor uso de punteros y referencias es cuando desea pasar o devolver un objeto de alg\u00fan tipo a una funci\u00f3n o bloque de funciones por \"referencia\" porque el objeto es demasiado grande o desea manipular el objeto pasado dentro de la funci\u00f3n/bloque de funci\u00f3n. Aseg\u00farese de que el lector de su c\u00f3digo sepa que va a cambiar el valor del objeto dentro de la funci\u00f3n/bloque de funciones si esto es lo que pretende hacer cuando lo pasa como argumento.</p>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#resumen-conclusiones","title":".Resumen / Conclusiones:","text":"<ul> <li>La memoria contiene miles y hasta millones de celdas o byte, en las que se ubica el c\u00f3digo del programa y todos los datos/variables. Cada celda tiene su n\u00famero, al que se llama direcci\u00f3n de memoria y que se suele expresar en hexadecimal 16#FA1204 -como ejemplo-</li> <li>Un puntero es una variable, que en lugar de contener un valor contiene una direcci\u00f3n de memoria, en la que \u201cvive\u201d la variable a la que realmente queremos acceder. </li> <li>Al igual que cualquier otra variable, hay que declarar los punteros para que el compilador pueda ubicarlos en la memoria.  Recordemos que un puntero es una variable, pero que su contenido es una direcci\u00f3n de memoria.</li> <li>Para cada tipo de variable se precisa el correspondiente tipo de puntero.  No se puede acceder a una variable INT con un puntero pensado para acceder a una estructura de datos.</li> <li>Nada tiene que ver el acceso indirecto a un array mediante una variable de \u00edndice, con un puntero.  En este caso el acceso est\u00e1 limitado al propio array, con el puntero se puede acceder a cualquier direcci\u00f3n de memoria.</li> <li>Con punteros se puede acceder a todo tipo de datos, en una simple l\u00ednea de c\u00f3digo se puede copiar una estructura entera de varios Kbytes de datos. Lo que resulta mucho m\u00e1s r\u00e1pido.</li> <li>Una referencia se parece mucho a un puntero, para simplificar podr\u00edamos decir que es un \u201calias\u201d de un objeto y que es algo menos cr\u00edtico que los punteros, su principal utilidad es la de pasar gran cantidad de par\u00e1metros a funciones, de forma muy simple y r\u00e1pida.</li> <li>El pase de par\u00e1metros a una funci\u00f3n se puede realizar de diversas formas, por valores, por punteros o por referencia, el programador deber\u00e1 elegir el m\u00e1s adecuado para cada aplicaci\u00f3n.</li> <li>Cuando se trata de grandes cantidades de datos el pase de par\u00e1metros por referencia o por punteros, ser\u00e1n los adecuados</li> </ul>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#links-de-puntero-y-referencia","title":"Links de Puntero y Referencia:","text":"<ul> <li> <p>\ud83d\udd17 Perre Garriga,Pointer&amp;Reference</p> </li> <li> <p>\ud83d\udd17 Control and use of Pointers In Codesys</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, Pointers</p> </li> <li> <p>\ud83d\udd17 AT&amp;U, CODESYS - Difference between pointer and reference</p> </li> <li> <p>\ud83d\udd17 AT&amp;U, CODESYS -Differente between pass by vale and pass by Reference</p> </li> <li> <p>\ud83d\udd17 Ninja Monkeys Tutorials, 21. TwinCAT 3: Pointer and References</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/pointer%20and%20reference/#link-al-video-de-youtube-011","title":"Link al Video de Youtube 011:","text":"<ul> <li>\ud83d\udd17 011 - OOP IEC 61131-3 PLC -- Puntero vs Referencia</li> </ul>"},{"location":"Clases%20y%20Objetos/propiedad/","title":"Objeto Propiedad","text":""},{"location":"Clases%20y%20Objetos/propiedad/#propiedades","title":"Propiedades:","text":"<p>Las propiedades son las principales variables de una clase. Se pueden utilizar como una alternativa a la clase regular o E/S del bloque de funciones. Las propiedades tienen m\u00e9todos Get \"Obtener\" y Set \"Establecer\" que permiten acceder y/o cambiar las variables:</p> <ul> <li>Get - M\u00e9todo que devuelve el valor de una variable.</li> <li>Set - M\u00e9todo que establece el valor de una variable.</li> </ul> <p>Al eliminar el m\u00e9todo \"Obtener\" o \"Establecer\", un programador puede hacer que las propiedades sean \"de solo escritura\" o \u201csolo lectura\u201d, respectivamente. Dado que estos son m\u00e9todos, significa que las propiedades pueden:</p> <ul> <li>Tener sus propias variables internas.</li> <li>Realizar operaciones antes de devolver su valor.</li> <li>No es necesario adjuntar la variable devuelta a una entrada o salida en particular (o variable interna) de la POU, puede devolver un valor basado en una determinada combinaci\u00f3n de sus variables.</li> <li>Ser accedido por evento en lugar de ser verificado en cada ciclo de ejecuci\u00f3n.</li> </ul>"},{"location":"Clases%20y%20Objetos/propiedad/#propiedades-getters-setters","title":"Propiedades: Getters &amp; Setters:","text":"<p>para modificar directamente nuestras propiedades lo que se busca es que se haga a trav\u00e9s de los metodos Getters y Setters, el cual var\u00eda la escritura seg\u00fan el lenguaje pero el concepto es el mismo.</p> <p>Por lo tanto, una declaraci\u00f3n de propiedad tiene la siguiente estructura:</p> <p><pre><code>PROPERTY &lt;Access specifier&gt; &lt;Name&gt; : &lt;Datatype&gt;\n</code></pre> En el Objeto Propiedad es obligatorio que retorne un valor.</p>"},{"location":"Clases%20y%20Objetos/propiedad/#especificadores-de-acceso","title":"Especificadores de acceso:","text":"<p>Al igual que con los m\u00e9todos, las propiedades tambi\u00e9n pueden tomar los siguientes especificadores de acceso: PUBLIC , PRIVATE , PROTECTED , INTERNAL y FINAL . Cuando no se define ning\u00fan especificador de acceso, la propiedad es PUBLIC . Adem\u00e1s, tambi\u00e9n se puede especificar un especificador de acceso para cada setter y getter. Esto tiene prioridad sobre el propio especificador de acceso de la propiedad.</p> <p>Las propiedades son reconocibles por las siguientes caracter\u00edsticas:</p> <p>Especificador de acceso:</p> <ul> <li>PUBLIC: <ul> <li>Corresponde a la especificaci\u00f3n de modificador sin acceso.</li> </ul> </li> <li>PRIVATE: <ul> <li>El acceso a la propiedad est\u00e1 limitado solo dentro de su propia Clase (Bloque de Funciones).</li> </ul> </li> <li>PROTECTED:<ul> <li>El acceso est\u00e1 restringido,no se puede acceder desde el programa principal, desde el MAIN.</li> </ul> </li> <li>INTERNAL:<ul> <li>El acceso a la propiedad est\u00e1 limitado al espacio de nombres, es decir, a la biblioteca.</li> </ul> </li> <li>FINAL: <ul> <li>No se permite sobrescribir la propiedad en un derivado del bloque de funciones. Esto significa que la propiedad no se puede sobrescribir ni extender en una subclase posiblemente existente.</li> <li>Las propiedades pueden ser abstractas, lo que significa que una propiedad no tiene una implementaci\u00f3n inicial y que la implementaci\u00f3n real se proporciona en el bloque de funciones derivado.</li> </ul> </li> </ul> <p>Los pragmas son muy \u00fatiles para monitorear propiedades en modo en l\u00ednea. Para esto, escr\u00edbalos en la parte superior de las declaraciones de propiedades (attribute 'monitoring'):</p> <p>{attribute 'monitoring := 'variable'}:  Al acceder a una propiedad, TwinCAT almacena el valor real en una variable y muestra el valor de esta \u00faltima. Este valor puede volverse obsoleto si el c\u00f3digo ya no accede a la propiedad.</p> <p>{attribute 'monitoring' := 'call'}:  Cada vez que se muestra el valor, TwinCAT llama al c\u00f3digo del descriptor de acceso Get. Cualquier efecto secundario, provocado por ese c\u00f3digo, puede aparecer en el seguimiento.</p>"},{"location":"Clases%20y%20Objetos/propiedad/#links-del-objeto-propiedad","title":"Links del Objeto Propiedad:","text":"<ul> <li> <p>\ud83d\udd17 Documentaci\u00f3n de Codesys del Objeto propiedad</p> </li> <li> <p>\ud83d\udd17 Documentaci\u00f3n de Beckhoff del Objeto propiedad</p> </li> <li> <p>\ud83d\udd17 utilizing-properties,twincontrols.com</p> </li> <li> <p>\ud83d\udd17 object-oriented-programming-in-programmable-logic-controllers-plc-whats-really-new,en.grse.de</p> </li> <li> <p>\ud83d\udd17 TC07.Beckhoff TwinCAT3 Function Block-Part2 Property.JP- DUT</p> </li> <li> <p>\ud83d\udd17 Nguy\u1ec5n V\u1ef9, Beckhoff &amp; PLC - OOP Properties| TWINCAT3</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/propiedad/#link-al-video-de-youtube-006","title":"Link al Video de Youtube 006:","text":"<ul> <li>\ud83d\udd17 006 - OOP IEC 61131-3 PLC -- Objeto Propiedad</li> </ul>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Bloque%20de%20Funcion/","title":"Herencia Bloque de Funcion","text":""},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Bloque%20de%20Funcion/#herencia-bloque-de-funcion","title":"Herencia Bloque de Funcion:","text":"<p>Los bloques de funciones son un medio excelente para mantener las secciones del programa separadas entre s\u00ed. Esto mejora la estructura del software y simplifica significativamente la reutilizaci\u00f3n. Anteriormente, ampliar la funcionalidad de un bloque de funciones existente siempre era una tarea delicada. Esto signific\u00f3 modificar el c\u00f3digo o programar un nuevo bloque de funciones alrededor del bloque existente (es decir, el bloque de funciones existente se incrust\u00f3 efectivamente dentro de un nuevo bloque de funciones). En el \u00faltimo caso, fue necesario crear todas las variables de entrada nuevamente y asignarlas a las variables de entrada para el bloque de funciones existente. Lo mismo se requer\u00eda, en sentido contrario, para las variables de salida.</p> <p>TwinCAT 3 y Codesys (IEC61131-3) introduce el concepto de herencia. La herencia es uno de los principios fundamentales de la programaci\u00f3n orientada a objetos. La herencia implica derivar un nuevo bloque de funciones a partir de un bloque de funciones existente. A continuaci\u00f3n, se puede ampliar el nuevo bloque. En la medida permitida por los especificadores de acceso del bloque de funciones principal, el nuevo bloque de funciones hereda todas las propiedades y m\u00e9todos del bloque de funciones principal. Cada bloque de funciones puede tener cualquier n\u00famero de bloques de funciones secundarios, pero solo un bloque de funciones principal. La derivaci\u00f3n de un bloque de funciones se produce en la nueva declaraci\u00f3n del bloque de funciones. El nombre del nuevo bloque de funciones va seguido de la palabra clave EXTENDS seguida del nombre del bloque de funciones principal. Por ejemplo:</p> <p><pre><code>FUNCTION_BLOCK PUBLIC FB_NewEngine EXTENDS FB_Engine\n</code></pre> El nuevo bloque de funciones derivado ( FB_NewEngine ) posee todas las propiedades y m\u00e9todos de su padre ( FB_Engine ). Sin embargo, los m\u00e9todos y las propiedades solo se heredan cuando el especificador de acceso lo permite.</p> <p>El bloque de funciones secundario tambi\u00e9n hereda todas las variables Locales, VAR_INPUT , VAR_OUTPUT y VAR_IN_OUT del bloque de funciones principal. Este comportamiento no se puede modificar mediante especificadores de acceso.</p> <p>Si los m\u00e9todos o las propiedades del bloque de funciones principal se han declarado como PROTECTED, el bloque de funciones secundario ( FB_NewEngine ) podr\u00e1 acceder a ellos, pero no desde fuera de FB_NewEngine .</p> <p>La herencia se aplica solo a las POU de tipo FUNCTION_BLOCK.</p>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Bloque%20de%20Funcion/#especificadores-de-acceso","title":"Especificadores de acceso:","text":"<p>Las declaraciones FUNCTION_BLOCK , FUNCTION o PROGRAM pueden incluir un especificador de acceso. Esto restringe el acceso y, en su caso, la capacidad de heredar.</p> <ul> <li>PUBLIC:</li> </ul> <p>Cualquiera puede llamar o crear una instancia de la POU. Adem\u00e1s, si la POU es un FUNCTION_BLOCK , se puede usar para la herencia. No se aplican restricciones.</p> <ul> <li>INTERN:</li> </ul> <p>La POU solo se puede utilizar dentro de su propio espacio de nombres. Esto permite que las POU est\u00e9n disponibles solo dentro de una determinada biblioteca, por ejemplo.</p> <ul> <li>FINAL:</li> </ul> <p>El FUNCTION_BLOCK no puede servir como un bloque de funciones principal. Los m\u00e9todos y las propiedades de esta POU no se pueden heredar. FINAL solo est\u00e1 permitido para POU del tipo FUNCTION_BLOCK .</p> <p>La configuraci\u00f3n predeterminada donde no se define ning\u00fan especificador de acceso es PUBLIC. Los especificadores de acceso PRIVATE y PROTECTED no est\u00e1n permitidos en las declaraciones de POU.</p> <p>Si planea utilizar la herencia, la declaraci\u00f3n del bloque de funciones tendr\u00e1 la siguiente estructura:</p> <pre><code>FUNCTION_BLOCK &lt;Access specifier&gt; &lt;Name&gt; EXTENDS &lt;Name basic function block&gt;\n</code></pre>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Bloque%20de%20Funcion/#metodos-de-sobrescritura","title":"M\u00e9todos de Sobrescritura:","text":"<p>El nuevo FUNCTION_BLOCK FB_NewEngine , que se deriva de FB_Engine , puede contener propiedades y m\u00e9todos adicionales. Por ejemplo, podemos agregar la propiedad Gear . Esta propiedad se puede utilizar para consultar y cambiar la marcha actual. Es necesario configurar getters y setters para esta propiedad.</p> <p>Sin embargo, tambi\u00e9n debemos asegurarnos de que el par\u00e1metro nGear del m\u00e9todo Start() se pase a esta propiedad. Debido a que el bloque de funciones principal FB_Engine no tiene acceso a esta nueva propiedad, se debe crear un nuevo m\u00e9todo con exactamente los mismos par\u00e1metros en FB_NewEngine . Copiamos el c\u00f3digo existente al nuevo m\u00e9todo y agregamos nuevo c\u00f3digo para que el par\u00e1metro nGear se pase a la propiedad Gear .</p> <p><pre><code>METHOD PUBLIC Start\nVAR_INPUT\nnGear : INT := 2;\nfVelocity : LREAL := 8.0;\nEND_VAR IF (fVelocity &lt; MaxVelocity) THEN\nvelocityInternal := fVelocity;\nELSE\nvelocityInternal := MaxVelocity;\nEND_IF\nGear := nGear; // new\n</code></pre> La l\u00ednea 12 copia el par\u00e1metro nGear a la propiedad Gear.</p> <p>Cuando un m\u00e9todo o propiedad que ya est\u00e1 presente en el bloque de funciones principal se redefine dentro del bloque de funciones secundario, esto se denomina sobrescritura. El bloque de funciones FB_NewEngine sobrescribe el m\u00e9todo Start().</p> <p>Por lo tanto, FB_NewEngine tiene la nueva propiedad Gear y sobrescribe el m\u00e9todo Start() .</p> <p></p> <p><pre><code>fbNewEngine.Start(1, 7.5);\n</code></pre> llama al m\u00e9todo Start() en FB_NewEngine, ya que este m\u00e9todo ha sido redefinido (sobrescrito) en FB_NewEngine .</p> <p>Mientras que:</p> <p><pre><code>fbNewEngine.Stop();\n</code></pre> llama al m\u00e9todo Stop() desde FB_Engine . El m\u00e9todo Stop() ha sido heredado por FB_NewEngine de FB_Engine .</p>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Bloque%20de%20Funcion/#links-herencia-bloque-de-funcion","title":"Links Herencia Bloque de Funcion:","text":"<ul> <li> <p>\ud83d\udd17 stefanhenneken.net,iec-61131-3-methods-properties-and-inheritance</p> </li> <li> <p>\ud83d\udd17 Simple Codesys OOP - Inheritance</p> </li> <li> <p>\ud83d\udd17 TC11.Beckhoff TwinCAT3 Function Block Extend.JP</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Bloque%20de%20Funcion/#link-al-video-de-youtube-007","title":"Link al Video de Youtube 007:","text":"<ul> <li>\ud83d\udd17 007 - OOP IEC 61131-3 PLC -- Herencia FB</li> </ul>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Estructura/","title":"Herencia Estructura","text":""},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Estructura/#herencia-estructura","title":"Herencia Estructura:","text":"<p>Al igual que los bloques de funciones, las estructuras se pueden ampliar. La estructura obtiene entonces las variables de la estructura b\u00e1sica adem\u00e1s de sus propias variables.</p> <p>Crear una estructura que extienda a otra Estructura: <pre><code>TYPE ST_Base1 :\nSTRUCT\nbBool1: BOOL;\niINT : INT;\nrReal : REAL;   END_STRUCT\nEND_TYPE\n</code></pre> <pre><code>TYPE ST_Sub1 EXTENDS ST_Base1:\nSTRUCT\nttime :TIME;\ntton  : TON;\nEND_STRUCT\nEND_TYPE\n</code></pre> <pre><code>TYPE ST_Sub2 EXTENDS ST_Sub1 :\nSTRUCT\nbBool2: BOOL; // No se podria llamar la variable bBool1 porque la tenemos declarada en la estructura ST_Base1\nEND_STRUCT\nEND_TYPE\n</code></pre> <pre><code>PROGRAM MAIN\nVAR\nstestructura1  : ST_Sub1;\nstestructura2  : ST_Sub2;\nEND_VAR\n\n//Extensi\u00f3n de Estructura:\nstestructura1.bBool1;\nstestructura1.iINT;\nstestructura1.rReal;\nstestructura1.ttime;\nstestructura1.tton(in:= TRUE, pt:=T#1S);\n\nstestructura2.bBool1;\nstestructura2.iINT;\nstestructura2.rReal;\nstestructura2.ttime;\nstestructura2.tton(in:= TRUE, pt:=T#1S);\nstestructura2.bBool2;\n</code></pre></p> <ul> <li> <p>De esta forma de extender una Estructura por Herencia no se pueden repetir el mismo nombre de variable declarada con las estructuras extendidas.</p> </li> <li> <p>Tambien sin usar EXTENDS para la Estructura podriamos realizarlo de la siguiente forma:</p> </li> </ul> <p><pre><code>TYPE ST_2 :\nSTRUCT\nbBool : BOOL;\nEND_STRUCT\nEND_TYPE\n</code></pre> <pre><code>TYPE ST_1:\nSTRUCT\nsStruct : ST_2;\nsstring : STRING(80);\nEND_STRUCT\nEND_TYPE\n</code></pre> <pre><code>PROGRAM MAIN\nVAR\nstestructura11 : ST_1;\nEND_VAR\n\nstestructura11.sstring;\nstestructura11.sStruct.bBool; //el resultado es que queda mas anidado\n</code></pre></p> <ul> <li> <p>De esta forma si que se pueden declarar el mismo nombre de la variable en diferentes Estructuras, ya que al estar anidadas no existe el problema anterior.</p> </li> <li> <p>No se permite la herencia m\u00faltiple de la siguiente forma:</p> </li> </ul> <pre><code>TYPE ST_Sub EXTENDS ST_Base1,ST_Base2 :\nSTRUCT\n</code></pre>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Estructura/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 infosys.beckhoff.com, Extends Structure</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, Structure</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, Structure</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, Structure</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Estructura/#link-al-video-de-youtube-008","title":"Link al Video de Youtube 008:","text":"<ul> <li>\ud83d\udd17 008 - OOP IEC 61131-3 PLC -- Herencia Estructura e Interface</li> </ul>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Interface/","title":"Herencia Interface","text":""},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Interface/#herencia-interface","title":"Herencia Interface:","text":"<p>Al igual que los bloques de funciones, las interfaces se pueden ampliar. A continuaci\u00f3n, la interface obtiene los m\u00e9todos de interface y las propiedades de la interface b\u00e1sica, adem\u00e1s de los suyos propios.</p> <p>Cree una interface que ampl\u00ede otra interface mediante la extensi\u00f3n:</p> <pre><code>INTERFACE I_Sub1 EXTENDS I_Base1, I_Base2\n</code></pre> <ul> <li>Se permite la herencia m\u00faltiple mediante la extensi\u00f3n de interfaces:</li> </ul> <pre><code>INTERFACE I_Sub2 EXTENDS I_Sub1\n</code></pre> <ul> <li>Se permite la herencia m\u00faltiple para las interfaces. Es posible que una interfaz ampl\u00ede a m\u00e1s de una interface.</li> </ul>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Interface/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 infosys.beckhoff.com, Extends Interface</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, Extends Interface</p> </li> </ul>"},{"location":"Clases%20y%20Objetos/Herencia/Herencia%20Interface/#link-al-video-de-youtube-008","title":"Link al Video de Youtube 008:","text":"<ul> <li>\ud83d\udd17 008 - OOP IEC 61131-3 PLC -- Herencia Estructura e Interface</li> </ul>"},{"location":"Conceptos%20Previos/Tabla%20de%20Modificadores%20de%20acceso/","title":"Tabla de Modificadores de acceso","text":"Modificadores de acceso FUNCTION_BLOCK - FB METODO PROPIEDAD PUBLIC Si Si Si INTERNAL Si Si Si FINAL Si Si Si ABSTRACT Si Si Si PRIVATE No Si Si PROTECTED No Si Si"},{"location":"Conceptos%20Previos/Tipos%20de%20datos/","title":"Tipos de Datos","text":""},{"location":"Conceptos%20Previos/Tipos%20de%20datos/#declaracion-de-una-variable","title":"Declaracion de una Variable:","text":"<p>La declaraci\u00f3n de variables en CODESYS \u00f3 TwinCAT incluir\u00e1:</p> <ul> <li>Un nombre de variable</li> <li>Dos puntos</li> <li>Un tipo de dato</li> <li>Un valor inicial opcional</li> <li>Un punto y coma</li> <li>Un comentario opcional</li> </ul> <p><pre><code>( &lt;pragma&gt; )*\n&lt;scope&gt; ( &lt;type qualifier&gt; )?\n&lt;identifier&gt; (AT &lt;address&gt; )? : &lt;data type&gt; ( := &lt;initial value&gt; )? ;\nEND_VAR\n</code></pre> - \ud83d\udd17 infosys.beckhoff.com, Declaring variables</p> <pre><code>VAR\n    nVar1   : INT := 12;                    // initialization value 12\n    nVar2   : INT := 13 + 8;                // initialization value defined by an expression of constants\n    nVar3   : INT := nVar2 + F_Fun(4);      //initialization value defined by an expression that contains a function call; notice the order!\n    pSample : POINTER TO INT := ADR(nVar1); //not described in the standard IEC61131-3: initialization value defined by an adress function; Notice: the pointer will not be initialized during an Online Change\nEND_VAR\n</code></pre>"},{"location":"Conceptos%20Previos/Tipos%20de%20datos/#tipos-de-datos","title":"\ud83d\udd17 Tipos de Datos:","text":""},{"location":"Conceptos%20Previos/Tipos%20de%20datos/#las-ventajas-de-las-estructuras-de-datos","title":"Las ventajas de las estructuras de datos.","text":"<ul> <li>La principal aportaci\u00f3n de las estructuras de datos y los tipos de datos  creados por el usuario es la claridad y el orden del c\u00f3digo resultante.</li> </ul>"},{"location":"Conceptos%20Previos/Tipos%20de%20datos/#estructuras-de-datos-struct","title":"Estructuras de datos: (STRUCT)","text":"<ul> <li>\ud83d\udd17 19. TwinCAT 3: Structures</li> <li>\ud83d\udd17 Extender una Estructura, Infosys Beckhoff</li> </ul>"},{"location":"Conceptos%20Previos/Tipos%20de%20datos/#datos-de-usuarioudt-user-data-type","title":"Datos de usuario:UDT (User Data Type):","text":"<p>Los UDT (User Data Type) son tipos de datos que el usuario crea a su medida,  seg\u00fan las necesidades de cada proyecto.</p> <p>When programming in TwinCAT, you can use different data types or instances of function blocks. You assign a data type to each identifier. The data type determines how much memory space is allocated and how these values are interpreted.</p> <p>The following groups of data types are available:</p>"},{"location":"Conceptos%20Previos/Tipos%20de%20datos/#standard-data-types","title":"Standard data types","text":"<p>TwinCAT supports all data types described in the IEC 61131-3 standard.</p> <ul> <li>BOOL</li> <li>Integer Data Types</li> <li>REAL / LREAL</li> <li>STRING</li> <li>WSTRING</li> <li>Time, date and time data types</li> <li>LTIME</li> </ul>"},{"location":"Conceptos%20Previos/Tipos%20de%20datos/#extensions-of-the-iec-61131-3-standard","title":"Extensions of the IEC 61131-3 standard","text":"<ul> <li>BIT</li> <li> <p>ANY and ANY_ <li> <p>http://soup01.com/ja/2023/06/13/post-8579/</p> </li> <li> <p>Special data types XINT, UXINT, XWORD and PVOID</p> </li> <li>REFERENCE</li> <li>UNION</li> <li>POINTER</li> <li> <p>Data type __SYSTEM.ExceptionCode</p> </li> <li> <p>T_ARG</p> </li> <li>https://infosys.beckhoff.com/content/1033/tcplclib_tc2_utilities/35376139.html?id=4303460770811510149</li> <li>http://soup01.com/ja/2023/06/23/post-8605/</li>"},{"location":"Conceptos%20Previos/Tipos%20de%20datos/#user-defined-data-types","title":"User-defined data types","text":"<p>Note the recommendations for naming objects.</p> <ul> <li>POINTER</li> <li>REFERENCE</li> <li>ARRAY</li> <li> <p>Subrange Types User-defined data types that you create as DUT object in the TwinCAT PLC project tree:</p> </li> <li> <p>Structure</p> </li> <li>Enumerations</li> <li>Alias</li> <li>UNION</li> </ul>"},{"location":"Conceptos%20Previos/Tipos%20de%20datos/#further-information","title":"Further Information","text":"<ul> <li>BOOL</li> <li>Integer Data Types</li> <li>Subrange Types</li> <li>BIT</li> <li>REAL / LREAL</li> <li>STRING</li> <li>WSTRING</li> <li>Time, date and time data types</li> <li>ANY and ANY_ <li>http://soup01.com/ja/2023/06/13/post-8579/</li> <li>Special data types XINT, UXINT, XWORD and PVOID</li> <li>POINTER</li> <li>Data type __SYSTEM.ExceptionCode</li> <li>Interface pointer / INTERFACE</li> <li>REFERENCE https://infosys.beckhoff.com/english.php?content=../content/1033/tc3_plc_intro/2529458827.html&amp;id=</li> <li>ARRAY</li> <li>Structure</li> <li>Enumerations</li> <li>Alias</li> <li> <p>UNION</p> </li> <li> <p>\ud83d\udd17 Special data types XINT, UXINT, XWORD and PVOID</p> </li>"},{"location":"Conceptos%20Previos/Tipos%20de%20datos/#links-tipos-de-datos","title":"Links Tipos de Datos:","text":"<ul> <li> <p>\ud83d\udd17 12. TwinCAT 3: Standard data types</p> </li> <li> <p>\ud83d\udd17 help.codesys.com, Tipos de datos</p> </li> <li> <p>\ud83d\udd17 www.infoplc.net, codesys-variables</p> </li> <li> <p>\ud83d\udd17 TC10.Beckhoff TwinCAT3 DUT\u69cb\u9020\u4f53.JP</p> </li> </ul>"},{"location":"Conceptos%20Previos/Variable%20types%20and%20special%20variables/","title":"Tipos de variables y variables especiales","text":""},{"location":"Conceptos%20Previos/Variable%20types%20and%20special%20variables/#variable-types-and-special-variables","title":"Variable types and special variables:","text":"<p>The variable type defines how and where you can use the variable. The variable type is defined during the variable declaration.</p>"},{"location":"Conceptos%20Previos/Variable%20types%20and%20special%20variables/#further-information","title":"Further Information:","text":"<ul> <li>Local Variables - VAR<ul> <li>Las variables locales se declaran en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n entre las palabras clave VAR y END_VAR.</li> <li>Puede extender las variables locales con una palabra clave de atributo.</li> <li>Puede acceder a variables locales para leer desde fuera de los objetos de programaci\u00f3n a trav\u00e9s de la ruta de instancia. El acceso para escribir desde fuera del objeto de programaci\u00f3n no es posible; Esto ser\u00e1 mostrado por el compilador como un error.</li> <li>Para mantener la encapsulaci\u00f3n de datos prevista, se recomienda encarecidamente no acceder a las variables locales de un POU desde fuera del POU, ni en modo de lectura ni en modo de escritura. (Otros compiladores de lenguaje de alto nivel tambi\u00e9n generan operaciones de acceso de lectura a variables locales como errores). Adem\u00e1s, con los bloques de funciones de biblioteca no se puede garantizar que las variables locales de un bloque de funciones permanezcan sin cambios durante las actualizaciones posteriores. Esto significa que es posible que el proyecto de aplicaci\u00f3n ya no se pueda compilar correctamente despu\u00e9s de la actualizaci\u00f3n de la biblioteca.</li> <li>Tambi\u00e9n observe aqu\u00ed la regla SA0102 del An\u00e1lisis Est\u00e1tico, que determina el acceso a las variables locales para la lectura desde el exterior.</li> </ul> </li> <li>Input Variables - VAR_INPUT<ul> <li>Las variables de entrada son variables de entrada para un bloque de funciones.</li> <li>VAR_INPUT variables se declaran en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n entre las palabras clave VAR_INPUT y END_VAR.</li> <li>Puede ampliar las variables de entrada con una palabra clave de atributo.</li> </ul> </li> <li>Output Variables - VAR_OUTPUT<ul> <li>Las variables de salida son variables de salida de un bloque de funciones.</li> <li>VAR_OUTPUT variables se declaran en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n entre las palabras clave VAR_OUTPUT y END_VAR. TwinCAT devuelve los valores de estas variables al bloque de funci\u00f3n de llamada. All\u00ed puede consultar los valores y continuar us\u00e1ndolos.</li> <li>Puede ampliar las variables de salida con una palabra clave de atributo.    </li> </ul> </li> <li>Input/Output Variables - VAR_IN_OUT, VAR_IN_OUT CONSTANT</li> <li>Global Variables - VAR_GLOBAL<ul> <li>Solo es posible su declaraci\u00f3n en GVL (Lista de Variables Global)</li> </ul> </li> <li>Temporary Variable - VAR_TEMP<ul> <li>Esta funcionalidad es una extensi\u00f3n con respecto a la norma IEC 61131-3.</li> <li>Las variables temporales se declaran localmente entre las palabras clave VAR_TEMP y END_VAR.</li> <li>VAR_TEMP declaraciones s\u00f3lo son posibles en programas y bloques de funciones.</li> <li>TwinCAT reinicializa las variables temporales cada vez que se llama al bloque de funciones.</li> <li>La aplicaci\u00f3n s\u00f3lo puede acceder a variables temporales en la parte de implementaci\u00f3n de un programa o bloque de funciones.</li> </ul> </li> <li>Static Variables - VAR_STAT<ul> <li>Esta funcionalidad es una extensi\u00f3n con respecto a la norma IEC 61131-3.</li> <li>Las variables est\u00e1ticas se declaran localmente entre las palabras clave VAR_STAT y END_VAR. TwinCAT inicializa las variables est\u00e1ticas cuando se llama por primera vez al bloque de funciones respectivo.</li> <li>Puede tener acceso a las variables est\u00e1ticas s\u00f3lo dentro del espacio de nombres donde se declaran las variables (como es el caso de las variables est\u00e1ticas en C). Sin embargo, las variables est\u00e1ticas conservan su valor cuando la aplicaci\u00f3n sale del bloque de funciones. Puede utilizar variables est\u00e1ticas, como contadores para llamadas a funciones, por ejemplo.</li> <li>Puede extender variables est\u00e1ticas con una palabra clave de atributo.</li> <li>Las variables est\u00e1ticas solo existen una vez. Esto tambi\u00e9n se aplica a las variables est\u00e1ticas de un bloque de funciones o un m\u00e9todo de bloque de funciones, incluso si el bloque de funciones se instancia varias veces.</li> </ul> </li> <li>External Variables - VAR_EXTERNAL<ul> <li>Las variables externas son variables globales que se \"importan\" en un bloque de funciones.</li> <li>Puede declarar las variables entre las palabras clave VAR_EXTERNAL y END_VAR. Si la variable global no existe, se emite un mensaje de error.  </li> <li>En TwinCAT 3 PLC no es necesario que las variables se declaren como externas. La palabra clave existe para mantener la compatibilidad con IEC 61131-3.</li> <li>Si, no obstante, utiliza variables externas, aseg\u00farese de abordar las variables asignadas (con AT %I o AT %Q) s\u00f3lo en la lista global de variables. El direccionamiento adicional de las instancias de variables locales dar\u00eda lugar a duplicaciones en la imagen del proceso.</li> <li>Estas variables declaradas tambien tiene que estar declarada la misma variable con el mismo nombre en una GVL (Lista de Varaibles Global)</li> </ul> </li> <li>Instance Variables - VAR_INST<ul> <li>TwinCAT crea una variable VAR_INST de un m\u00e9todo no en la pila de m\u00e9todos como las variables VAR, sino en la pila de la instancia del bloque de funciones. Esto significa que la variable VAR_INST se comporta como otras variables de la instancia del bloque de funci\u00f3n y no se reinicializa cada vez que se llama al m\u00e9todo.</li> <li>VAR_INST variables solo est\u00e1n permitidas en los m\u00e9todos de un bloque de funciones, y el acceso a dicha variable solo est\u00e1 disponible dentro del m\u00e9todo. Puede supervisar los valores de las variables de instancia en la parte de declaraci\u00f3n del m\u00e9todo.</li> <li>Las variables de instancia no se pueden extender con una palabra clave de atributo.</li> </ul> </li> <li>Remanent Variables - PERSISTENT, RETAIN Las variables remanentes pueden conservar sus valores m\u00e1s all\u00e1 del tiempo de ejecuci\u00f3n habitual del programa. Las variables remanentes se pueden declarar como variables RETAIN o incluso m\u00e1s estrictamente como variables PERSISTENTES en el proyecto PLC.</li> </ul> <p>Un requisito previo para la funcionalidad completa de las variables RETAIN es un \u00e1rea de memoria correspondiente en el controlador (NovRam). Las variables persistentes se escriben solo cuando TwinCAT se apaga. Esto requerir\u00e1 generalmente un UPS correspondiente. Excepci\u00f3n: Las variables persistentes tambi\u00e9n se pueden escribir con el bloque de funci\u00f3n FB_WritePersistentData.</p> <p>Si el \u00e1rea de memoria correspondiente no existe, los valores de las variables RETAIN y PERSISTENT se pierden durante un corte de energ\u00eda.</p> <p>La declaraci\u00f3n AT no debe utilizarse en combinaci\u00f3n con VAR RETAIN o VAR PERSISTENT.</p>"},{"location":"Conceptos%20Previos/Variable%20types%20and%20special%20variables/#variables-persistentes","title":"Variables persistentes","text":"<p>Puede declarar variables persistentes agregando la palabra clave PERSISTENT despu\u00e9s de la palabra clave para el tipo de variable (VAR, VAR_GLOBAL, etc.) en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n.</p> <p>Las variables PERSISTENTES conservan su valor despu\u00e9s de una terminaci\u00f3n no controlada, un Reset cold o una nueva descarga del proyecto PLC. Cuando el programa se reinicia, el sistema contin\u00faa funcionando con los valores almacenados. En este caso, TwinCAT reinicializa las variables \"normales\" con sus valores iniciales especificados expl\u00edcitamente o con las inicializaciones predeterminadas. En otras palabras, TwinCAT solo reinicializa las variables PERSISTENTES durante un origen de Restablecer.</p> <p>Un ejemplo de aplicaci\u00f3n para variables persistentes es un contador de horas de funcionamiento, que debe continuar contando despu\u00e9s de un corte de energ\u00eda y cuando el proyecto PLC se descarga nuevamente.</p> <p>Evite usar el tipo de datos POINTER TO en listas de variables persistentes, ya que los valores de direcci\u00f3n pueden cambiar cuando el proyecto PLC se descargue nuevamente. TwinCAT emite las advertencias correspondientes del compilador. Declarar una variable local como PERSISTENTE en una funci\u00f3n no tiene ning\u00fan efecto. La persistencia de datos no se puede utilizar de esta manera. El comportamiento durante un restablecimiento en fr\u00edo puede verse influenciado por el pragma 'TcInitOnReset'</p>"},{"location":"Conceptos%20Previos/Variable%20types%20and%20special%20variables/#variables-retain","title":"Variables RETAIN","text":"<p>Puede declarar variables RETAIN agregando la palabra clave RETAIN despu\u00e9s de la palabra clave para el tipo de variable (VAR, VAR_GLOBAL, etc.) en la parte de declaraci\u00f3n de los objetos de programaci\u00f3n.</p> <p>Las variables declaradas como RETAIN dependen del sistema de destino, pero normalmente se administran en un \u00e1rea de memoria separada que debe protegerse contra fallas de energ\u00eda. El llamado controlador Retain asegura que las variables RETAIN se escriban al final de un ciclo PLC y solo en el \u00e1rea correspondiente de la NovRam. El manejo del controlador de retenci\u00f3n se describe en el cap\u00edtulo \"Conservar datos\" de la documentaci\u00f3n de C/C++.</p> <p>Las variables RETAIN conservan su valor despu\u00e9s de una terminaci\u00f3n incontrolada (corte de energ\u00eda). Cuando el programa se reinicia, el sistema contin\u00faa funcionando con los valores almacenados. En este caso, TwinCAT reinicializa las variables \"normales\" con sus valores iniciales especificados expl\u00edcitamente o con las inicializaciones predeterminadas. TwinCAT reinicializa las variables RETAIN en un origen de restablecimiento.</p> <p>Una posible aplicaci\u00f3n es un contador de piezas en una planta de producci\u00f3n, que debe seguir contando despu\u00e9s de un corte de energ\u00eda.</p> <p>Si declara una variable local como RETAIN en un programa o bloque de funciones, TwinCAT almacena esta variable espec\u00edfica en el \u00e1rea de retenci\u00f3n (como una variable RETEAIN global). Si declara una variable local en una funci\u00f3n como RETAIN, esto no tiene efecto. TwinCAT no almacena la variable en el \u00e1rea de retenci\u00f3n.</p>"},{"location":"Conceptos%20Previos/Variable%20types%20and%20special%20variables/#cuadro-general-completo","title":"Cuadro general completo","text":"<p>El grado de retenci\u00f3n de las variables RETAIN se incluye autom\u00e1ticamente en el de las variables PERSISTENT.</p> Despu\u00e9s del comando en l\u00ednea VAR VAR RETAIN VAR PERSISTENT Restablecer fr\u00edo Los valores se reinicializan Los valores se mantienen Los valores se mantienen Restablecer origen Los valores se reinicializan Los valores se reinicializan Los valores se reinicializan Descargar Los valores se reinicializan Los valores se mantienen Los valores se mantienen Cambio en l\u00ednea Los valores se mantienen Los valores se mantienen Los valores se mantienen <ul> <li>SUPER</li> <li>THIS</li> <li>Variable types - attribute keywords<ul> <li>RETAIN: for remanent variables of type RETAIN</li> <li>PERSISTENT: for remanent variables of type PERSISTENT</li> <li>CONSTANT: for constants</li> </ul> </li> </ul>"},{"location":"Conceptos%20Previos/Variable%20types%20and%20special%20variables/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 Local Variables - VAR, infosys.beckhoff.com/</p> </li> <li> <p>\ud83d\udd17 Instance Variables - VAR_INST, infosys.beckhoff.com/</p> </li> <li> <p>\ud83d\udd17 www.plccoder.com/instance-variables-with-var_inst</p> </li> <li> <p>\ud83d\udd17 www.plccoder.com/var_temp-var_stat-and-var_const</p> </li> <li> <p>\ud83d\udd17 Tipos de variables y variables especiales</p> </li> </ul>"},{"location":"Conceptos%20Previos/modificadores%20de%20acceso/","title":"Modificadores de acceso","text":""},{"location":"Conceptos%20Previos/modificadores%20de%20acceso/#modificadores-de-acceso","title":"Modificadores de Acceso:","text":"<ul> <li>PUBLIC: <ul> <li>Son accesibles luego de instanciar la clase.</li> <li>Corresponde a la especificaci\u00f3n de modificador sin restricci\u00f3n de acceso.</li> </ul> </li> <li>PRIVATE: <ul> <li>Son accesibles solo dentro de la clase.</li> <li>El acceso est\u00e1 restringido al bloque de funciones Heredado y en el programa MAIN, respectivamente.</li> </ul> </li> <li>PROTECTED: <ul> <li>Son accesibles dentro de la clase.</li> <li>Son accesibles a trav\u00e9s de la herencia.</li> <li>El acceso est\u00e1 restringido, no se puede acceder desde el programa principal, desde el MAIN.</li> </ul> </li> <li>INTERNAL:<ul> <li>El acceso est\u00e1 limitado al espacio de nombres (la biblioteca).  </li> </ul> </li> <li>FINAL:<ul> <li>No se permite sobrescribir, en un derivado del bloque de funciones. </li> <li>Esto significa que no se puede sobrescribir/extender en una subclase posiblemente existente.</li> </ul> </li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/Adapter%20Design%20Pattern/","title":"Patron Adaptador","text":"<ul> <li>\ud83d\udd17 Patr\u00f3n de dise\u00f1o Adapter en C#</li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/Decorator%20Design%20Pattern/","title":"Patron Decorador","text":""},{"location":"Patrones%20de%20Dise%C3%B1o/Decorator%20Design%20Pattern/#links-de-patrones-de-diseno","title":"Links de Patrones de Dise\u00f1o:","text":"<ul> <li>\ud83d\udd17 Decorator Design Pattern</li> <li>\ud83d\udd17 \ud83e\udd29PATRONES de DISE\u00d1O con Typescript - Decorator Pattern | PT 2.</li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/Factory%20Method%20Design%20Pattern/","title":"Patron Metodo de Fabrica","text":""},{"location":"Patrones%20de%20Dise%C3%B1o/Factory%20Method%20Design%20Pattern/#links-de-patrones-de-diseno","title":"Links de Patrones de Dise\u00f1o:","text":"<ul> <li>\ud83d\udd17 Factory Method Design Pattern</li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/Observer%20Design%20Pattern/","title":"Patron Observador","text":""},{"location":"Patrones%20de%20Dise%C3%B1o/Observer%20Design%20Pattern/#links-de-patrones-de-diseno","title":"Links de Patrones de Dise\u00f1o:","text":"<ul> <li>\ud83d\udd17 Observer Design Pattern </li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/Strategy%20pattern/","title":"Patron de Estrategia","text":""},{"location":"Patrones%20de%20Dise%C3%B1o/Strategy%20pattern/#links-de-patrones-de-diseno","title":"Links de Patrones de Dise\u00f1o:","text":"<ul> <li> <p>\ud83d\udd17 TwinCAT with Head First Design Patterns Ch.1 - Intro/Strategy Pattern</p> </li> <li> <p>\ud83d\udd17 PATRONES de DISE\u00d1O en PROGRAMACI\u00d3N FUNCIONAL</p> </li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/The%20Abstract%20Factory%20Pattern/","title":"Patron Fabrica Abstracta","text":""},{"location":"Patrones%20de%20Dise%C3%B1o/The%20Abstract%20Factory%20Pattern/#links-de-patrones-de-diseno","title":"Links de Patrones de Dise\u00f1o:","text":"<ul> <li> <p>\ud83d\udd17 iec-61131-6-abstract-factory-english,stefanhenneken.net</p> </li> <li> <p>\ud83d\udd17 Abstract Factory Design Pattern</p> </li> <li> <p>\ud83d\udd17 refactoring.guru,abstract-factory</p> </li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/The%20Visitor%20Design%20Pattern/","title":"Patron Visitante","text":""},{"location":"Patrones%20de%20Dise%C3%B1o/The%20Visitor%20Design%20Pattern/#links-de-patrones-de-diseno","title":"Links de Patrones de Dise\u00f1o:","text":"<ul> <li>\ud83d\udd17Design Patterns - The Visitor Pattern</li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/_Patrones%20de%20Dise%C3%B1o/","title":"Patrones de Dise\u00f1o","text":""},{"location":"Patrones%20de%20Dise%C3%B1o/_Patrones%20de%20Dise%C3%B1o/#patrones-de-diseno","title":"PATRONES DE DISE\u00d1O:","text":"<p>Los patrones de dise\u00f1o son soluciones generales y reutilizables para problemas comunes que se encuentran en la programaci\u00f3n de software. En la programaci\u00f3n orientada a objetos, existen muchos patrones de dise\u00f1o que se pueden aplicar para mejorar la modularidad, la flexibilidad y el mantenimiento del c\u00f3digo. Algunos ejemplos de patrones de dise\u00f1o que se pueden aplicar en la programaci\u00f3n de PLCs incluyen el patr\u00f3n Singleton, el patr\u00f3n Factory Method, el patr\u00f3n Observer y el patr\u00f3n Strategy. Por ejemplo, el patr\u00f3n Singleton se utiliza para garantizar que solo exista una instancia de una clase determinada en todo el programa. Esto puede ser \u00fatil en la programaci\u00f3n de PLCs cuando se quiere asegurar que solo hay una instancia activa del objeto que controla un determinado proceso o dispositivo. El patr\u00f3n Factory Method se utiliza para crear instancias de objetos sin especificar expl\u00edcitamente la clase concreta a instanciar. Esto puede ser \u00fatil en la programaci\u00f3n de PLCs cuando se quiere crear objetos seg\u00fan las necesidades espec\u00edficas del programa. El patr\u00f3n Observer se utiliza para establecer una relaci\u00f3n uno a muchos entre objetos, de manera que cuando un objeto cambia su estado, todos los objetos relacionados son notificados autom\u00e1ticamente. Este patr\u00f3n puede ser muy \u00fatil en la programaci\u00f3n de PLCs para establecer relaciones entre diferentes componentes del sistema, como sensores y actuadores. El patr\u00f3n Strategy se utiliza para definir un conjunto de algoritmos intercambiables, y luego encapsular cada uno como un objeto. Este patr\u00f3n puede ser \u00fatil en la programaci\u00f3n de PLCs cuando se desea cambiar din\u00e1micamente el comportamiento del sistema seg\u00fan las condiciones del entorno. En resumen, los patrones de dise\u00f1o son una herramienta muy \u00fatil para mejorar la calidad del c\u00f3digo en la programaci\u00f3n de PLCs y se pueden aplicar con \u00e9xito en la programaci\u00f3n orientada a objetos para PLCs.</p> <pre><code>\u201cLos patrones de dise\u00f1o son \ndescripciones de objetos y clases \nconectadas que se personalizan para \nresolver un problema de dise\u00f1o \ngeneral en un contexto particular\u201d. \n- Gang of Four \n</code></pre> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>Clasificaci\u00f3n seg\u00fan su prop\u00f3sito:  Los patrones de dise\u00f1o se clasificaron originalmente en tres grupos: </p> <ul> <li>Creacionales. </li> <li>Estructurales. </li> <li>De comportamiento. </li> </ul> <p>Clasificaci\u00f3n seg\u00fan su \u00e1mbito:</p> <ul> <li>De clase: Basados en la herencia de clases. </li> <li>De objeto: Basados en la utilizaci\u00f3n din\u00e1mica de objetos. </li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/_Patrones%20de%20Dise%C3%B1o/#patrones-creacionales","title":"Patrones Creacionales:","text":"<ul> <li> <p>Los patrones de Creaci\u00f3n abstraen la forma en que se crean los objetos, de forma que permite tratar las clases a crear de forma gen\u00e9rica apartando la decisi\u00f3n de qu\u00e9 clases crear o como crearlas.  Pero los Patrones de Dise\u00f1o son conceptos aplicables directamente en la producci\u00f3n de software, cualquier abstracci\u00f3n no se queda en el aire como una entelequia que solo sirve para dar discursos, as\u00ed: Seg\u00fan a donde quede desplazada dicha decisi\u00f3n se habla de Patrones de Clase (utiliza la herencia para determinar la creaci\u00f3n de las instancias, es decir en los constructores de las clases) o Patrones de Objeto (es en m\u00e9todos de los objetos creados donde se modifica la clase) </p> </li> <li> <p>Patrones de Creaci\u00f3n de Clase:</p> <ul> <li>Factor\u00eda Abstracta </li> <li>Builder </li> </ul> </li> <li> <p>Patrones de Creaci\u00f3n de Objeto: </p> <ul> <li>M\u00e9todo Factor\u00eda </li> <li>Prototipo </li> <li>Singleton </li> <li>Object Pool </li> </ul> </li> <li> <p>Builder*</p> </li> <li>Singleton *</li> <li>Dependency Injection </li> <li>Service Locator </li> <li>Abstract Factory*</li> <li>Factory Method *</li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/_Patrones%20de%20Dise%C3%B1o/#patrones-estructurales","title":"Patrones Estructurales:","text":"<p>Tratan la relaci\u00f3n entre clases, la combinaci\u00f3n clases y la formaci\u00f3n de estructuras de mayor complejidad.  - Adapter - Data Access Object (DAO) - Query Object  - Decorator  - Bridge </p>"},{"location":"Patrones%20de%20Dise%C3%B1o/_Patrones%20de%20Dise%C3%B1o/#patrones-de-comportamiento","title":"Patrones de Comportamiento:","text":"<p>Los patrones de comportamiento hablan de como interaccionan entre si los objetos para conseguir ciertos resultados.  Los principales patrones de comportamiento son: </p> <ul> <li>Command</li> <li>Chain of Responsibility </li> <li>Strategy</li> <li>Template Method </li> <li>Interpreter</li> <li>Observer </li> <li>State </li> <li>Visitor </li> <li>Iterator</li> </ul> <p>Los patrones de dise\u00f1o son soluciones reutilizables para problemas comunes de dise\u00f1o de software. Proporcionan una forma para que los desarrolladores de software resuelvan problemas comunes de manera consistente y eficiente, sin tener que reinventar la rueda cada vez.</p> <p>Beneficios de usar Patrones de Dise\u00f1o =&gt;</p> <p>\u2022 Reusabilidad: Evite reinventar la rueda cada vez.</p> <p>\u2022 Escalabilidad: Dise\u00f1o de software flexible y adaptable.</p> <p>\u2022 Capacidad de mantenimiento: C\u00f3digo m\u00e1s f\u00e1cil de modificar y depurar.</p> <p>\u2022 Estandarizaci\u00f3n: Vocabulario com\u00fan y estructura a trav\u00e9s de diferentes proyectos.</p> <p>\u2022 Colaboraci\u00f3n: m\u00e1s f\u00e1cil para varios desarrolladores trabajar en el mismo c\u00f3digo base.</p> <p>Algunos patrones de dise\u00f1o de uso com\u00fan =&gt;</p> <p>\u2022 Patr\u00f3n de estrategia: el patr\u00f3n de estrategia se utiliza para definir una familia de algoritmos, encapsular cada uno y hacerlos intercambiables.</p> <p>Por ejemplo, imagina que tienes un juego con diferentes tipos de personajes, cada uno con sus propias habilidades \u00fanicas. El patr\u00f3n de estrategia le permitir\u00eda definir un conjunto de estrategias (es decir, algoritmos) para cada tipo de personaje y luego cambiar f\u00e1cilmente entre ellas seg\u00fan sea necesario.</p> <p>\u2022 Patr\u00f3n de observador: el patr\u00f3n de observador se utiliza para notificar a los objetos cuando hay un cambio en otro objeto.</p> <p>Por ejemplo, imagine que tiene una aplicaci\u00f3n meteorol\u00f3gica que necesita notificar a sus usuarios cuando cambia la temperatura. El patr\u00f3n de observador le permitir\u00eda definir un conjunto de observadores (es decir, los usuarios) y luego notificarles cuando cambie la temperatura.</p> <p>\u2022 Patr\u00f3n de decorador: el patr\u00f3n de decorador se utiliza para agregar funcionalidad a un objeto de forma din\u00e1mica, sin cambiar su estructura original.</p> <p>Por ejemplo, imagine que tiene un autom\u00f3vil y desea agregarle un sistema de navegaci\u00f3n GPS. El patr\u00f3n decorador le permitir\u00eda agregar el sistema GPS sin tener que modificar el propio autom\u00f3vil.</p> <p>\u2022 Patr\u00f3n de comando: el patr\u00f3n de comando se usa para encapsular una solicitud como un objeto, lo que permite que se almacene, pase y ejecute en un momento posterior.</p> <p>Por ejemplo, imagina que tienes un sistema de automatizaci\u00f3n del hogar que te permite controlar las luces, el termostato y otros dispositivos. El patr\u00f3n de comando le permitir\u00eda encapsular cada comando (por ejemplo, encender las luces), almacenarlo como un objeto y ejecutarlo m\u00e1s tarde.</p> <p>\u2022 Patr\u00f3n de f\u00e1brica: el patr\u00f3n de f\u00e1brica se utiliza para crear objetos sin exponer la l\u00f3gica de creaci\u00f3n al cliente.</p> <p>Por ejemplo, imagina que tienes un juego con diferentes niveles, cada uno con su propio conjunto de enemigos. El patr\u00f3n de f\u00e1brica te permitir\u00eda crear enemigos para cada nivel sin exponer la l\u00f3gica de creaci\u00f3n al cliente.</p> <p>\u2022 Patr\u00f3n compuesto: el patr\u00f3n compuesto se utiliza para crear una estructura de objetos en forma de \u00e1rbol, donde los objetos individuales y los grupos de objetos se tratan de la misma manera.</p> <p>Por ejemplo, imagine que tiene un sistema de archivos, donde los archivos y los directorios se tratan de la misma manera. El patr\u00f3n compuesto le permitir\u00eda tratar archivos y directorios individuales como el mismo tipo de objeto y crear una estructura similar a un \u00e1rbol de todo el sistema de archivos.</p> <p>Adem\u00e1s de los Patrones de Dise\u00f1o tenemos:</p> <ul> <li>Patrones de Arquitectura. Formas de descomponer, conectar y relacionar sistemas, trata conceptos como: niveles, tuber\u00edas y filtros. Es un nivel de abstracci\u00f3n mayor que el de los Patrones de Dise\u00f1o. </li> <li>Patrones de Programaci\u00f3n (Idioms Patterns). Patrones de bajo nivel acerca de un lenguaje de programaci\u00f3n concreto, describen como implementar cuestiones concretas. </li> <li>Patrones de Analisis. Conjunto de reglas que permiten modelar un sistema de forma satisfactoria. </li> <li>Patrones de Organizacionales. Describen como organizar grupos humanos, generalmente relacionados con el software. </li> <li>Otros Patrones de Software. Se puede hablar de patrones de Programaci\u00f3n concurrente, de Interfaz Gr\u00e1fica, de Organizaci\u00f3n de C\u00f3digo, de Optimizaci\u00f3n de C\u00f3digo, de Robustez de C\u00f3digo, de Fase de Prueba. </li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/_Patrones%20de%20Dise%C3%B1o/#links-de-patrones-de-diseno","title":"Links de Patrones de Dise\u00f1o:","text":"<ul> <li>\ud83d\udd17 refactoring.guru/es/design-patterns</li> <li>\ud83d\udd17 0w8States/PLC-Design-Patterns</li> <li>\ud83d\udd17 github.com/Aliazzzz/Applied-Design-Patterns-in-CODESYS-V3</li> <li>\ud83d\udd17 sourcemaking.com/design_patterns</li> <li>\ud83d\udd17 Coding Together ES, Patrones de Dise\u00f1o</li> </ul>"},{"location":"Patrones%20de%20Dise%C3%B1o/_Patrones%20de%20Dise%C3%B1o/#link-al-video-de-youtube_nnn","title":"Link al Video de Youtube_NNN:","text":""},{"location":"TDD/Integration%20Test/","title":"Pruebas Integracion","text":""},{"location":"TDD/Integration%20Test/#pruebas-de-integracion","title":"Pruebas de Integraci\u00f3n:","text":"<p>Las pruebas de integraci\u00f3n son una parte cr\u00edtica del proceso de desarrollo de software. Ayuda a los desarrolladores a garantizar que los componentes externos de un sistema funcionen como se espera. </p>"},{"location":"TDD/Integration%20Test/#cual-es-la-diferencia-entre-las-pruebas-de-integracion-y-las-pruebas-unitarias","title":"\u00bfcu\u00e1l es la diferencia entre las pruebas de integraci\u00f3n y las pruebas unitarias?","text":"<p>Las pruebas de integraci\u00f3n juegan un papel fundamental en la evaluaci\u00f3n del funcionamiento adecuado de la infraestructura de soporte de una aplicaci\u00f3n, incluida la base de datos, el sistema de archivos y las dependencias externas. </p> <p>A diferencia de las pruebas unitarias que se centran en unidades de c\u00f3digo individuales de forma aislada, las pruebas de integraci\u00f3n simulan dependencias externas del mundo real para verificar que los componentes funcionen juntos sin problemas y para detectar cualquier defecto que pueda surgir durante la integraci\u00f3n.</p>"},{"location":"TDD/Test%20Driven%20Development/","title":"TDD - Desarrollo guiado por pruebas","text":""},{"location":"TDD/Test%20Driven%20Development/#desarrollo-guiado-por-pruebas","title":"Desarrollo Guiado por Pruebas:","text":"<p>La clave del TDD o Test Driven Development es que en este proceso se escriben las pruebas antes de escribir el c\u00f3digo. Este sistema consigue no solo mejorar la calidad del software final, sino que, adem\u00e1s, ayuda a reducir los costes de mantenimiento.</p> <p>La premisa detr\u00e1s del desarrollo dirigido por pruebas, seg\u00fan Kent Beck, es que todo el c\u00f3digo debe ser probado y refactorizado continuamente. Kent Beck lo expresa de esta manera: Sencillamente, el desarrollo dirigido por pruebas tiene como objetivo eliminar el miedo en el desarrollo de aplicaciones.</p> <ul> <li>Est\u00e1 creando documentaci\u00f3n, especificaciones vivas y nunca obsoletas (es decir, documentaci\u00f3n).</li> <li>Est\u00e1 (re)dise\u00f1ando su c\u00f3digo para hacerlo y mantenerlo f\u00e1cilmente comprobable. Y eso lo hace limpio, sin complicaciones y f\u00e1cil de entender y cambiar.</li> <li>Est\u00e1 creando una red de seguridad para hacer cambios con confianza.</li> <li>Notificaci\u00f3n temprana de errores.</li> <li>Diagn\u00f3stico sencillo de los errores, ya que las pruebas identifican lo que ha fallado.</li> </ul>"},{"location":"TDD/Test%20Driven%20Development/#el-ciclo-y-las-etapas-del-tdd","title":"El Ciclo y las Etapas del TDD:","text":"<p>El Desarrollo Dirigido por Pruebas significa pasar por tres fases. Una y otra vez.</p> <ul> <li>Fase roja: escribir una prueba.</li> <li>Fase verde: hacer que la prueba pase escribiendo el c\u00f3digo que vigila.</li> <li>Fase azul: refactorizar.</li> </ul>"},{"location":"TDD/Test%20Driven%20Development/#niveles-de-testing","title":"Niveles de Testing:","text":"<ul> <li>El Desarrollo Guiado por Pruebas debe de empezarse a implementar lo mas temprano posible en el desarrollo del Software.</li> <li>Las pruebas solo son \u00fatiles cuando se ejecutan. Configurar un sistema de integraci\u00f3n continua para construir y probar cada componente cada vez que hay un cambio en el c\u00f3digo fuente es el camino a seguir.</li> </ul>"},{"location":"TDD/Test%20Driven%20Development/#como-conseguimos-un-desarrollo-guiado-por-pruebas-tdd-en-plcs","title":"\u00bfComo Conseguimos un Desarrollo Guiado por Pruebas TDD en PLCs?:","text":"<p>Vamos a ver una lista de todas las implementaciones que he encontrado para conseguirlo:</p> <p>-</p>"},{"location":"TDD/Test%20Driven%20Development/#links-desarrollo-guiado-por-pruebas","title":"Links Desarrollo Guiado por Pruebas:","text":"<ul> <li>\ud83d\udd17 www.nimblework.com, desarrollo-dirigido-por-pruebas-tdd</li> <li>\ud83d\udd17 leanpub.com/tdd-ebook/read</li> <li>\ud83d\udd17 Pruebas unitarias y Test-Driven Development | Ejemplo desde cero</li> <li>\ud83d\udd17 programacionymas.com, tipos-de-testing-en-desarrollo-de-software</li> </ul>"},{"location":"TDD/Test%20Driven%20Development/#link-al-video-de-youtube_nnn","title":"Link al Video de Youtube_NNN:","text":""},{"location":"TDD/Unit%20Test/","title":"Pruebas Unitarias","text":""},{"location":"TDD/Unit%20Test/#links-pruebas-unitarias","title":"Links Pruebas Unitarias:","text":"<ul> <li>\ud83d\udd17 https://tcunit.org/</li> <li>\ud83d\udd17 https://github.com/tcunit/TcUnit</li> <li>\ud83d\udd17 https://github.com/PeterZerlauth/Testing</li> <li>\ud83d\udd17</li> <li>\ud83d\udd17</li> <li>\ud83d\udd17</li> <li>\ud83d\udd17</li> <li>\ud83d\udd17 C#: Desarrollo Test Driven</li> <li>\ud83d\udd17 Visual Studio: Unit Tests esencial</li> </ul>"},{"location":"UML/Class%20UML/","title":"Class UML","text":""},{"location":"UML/Class%20UML/#diagrama-de-clases-en-uml","title":"Diagrama de Clases en UML:","text":""},{"location":"UML/Class%20UML/#que-son","title":"\u00bfQu\u00e9 son?:","text":"<ul> <li>El diagrama de clases es un diagrama que muestra \"c\u00f3mo\" se organiza y estructura un sistema.</li> <li>Se enfoca en la estructura interna del sistema y muestra c\u00f3mo est\u00e1 organizado en t\u00e9rminos de clases y objetos.</li> <li>Describe c\u00f3mo se implementar\u00e1 el sistema desde una perpectiva orientada a objetos.</li> </ul>"},{"location":"UML/Class%20UML/#para-que-sirve","title":"\u00bfPara qu\u00e9 sirve?:","text":"<ul> <li>Representar la estructura del sistema</li> <li>Visualizar relaciones</li> <li>Facilitar el dise\u00f1o del sistema</li> <li>Documentar el sistema</li> <li>Promover la reutilizaci\u00f3n</li> <li>Facilitar la comunicaci\u00f3n</li> <li>Base para otros diagramas UML</li> </ul>"},{"location":"UML/Class%20UML/#representacion-grafica","title":"Representaci\u00f3n gr\u00e1fica:","text":"<ul> <li>Para representar Objetos y Clases, se utiliza el \"clasificador\".</li> <li>Cada caja representa un bloque de funci\u00f3n y siempre se divide en tres secciones horizontales. </li> <li>La secci\u00f3n superior muestra el nombre del bloque de funciones.</li> <li>La secci\u00f3n central enumera sus atributos/propiedades.</li> <li>La secci\u00f3n inferior enumera todos sus operaciones/m\u00e9todos. </li> </ul> <p>Los Modificadores de acceso de los metodos y las propiedades tienen una Visibilidad y su simbologia es la siguiente:</p> <p></p> <p>La jerarqu\u00eda de herencia se puede representar en forma de diagrama. </p> <p>El lenguaje de modelado unificado (UML) es el est\u00e1ndar establecido en esta \u00e1rea. UML define varios tipos de diagramas que describen tanto la estructura como el comportamiento del software.</p> <p>Una buena herramienta para describir la jerarqu\u00eda de herencia de bloques de funciones es el diagrama de clases.</p> <p>Los diagramas UML se pueden crear directamente en TwinCAT 3. Los cambios en el diagrama UML tienen un efecto directo en las POU. Por lo tanto, los bloques de funciones se pueden modificar y modificar a trav\u00e9s del diagrama UML.</p> <p>Los Modificadores de acceso de los metodos y las propiedades se veran segun la simbologia:(Disponible a partir de la versi\u00f3n de TwinCAT 3.1.4026)</p> <p></p>"},{"location":"UML/Class%20UML/#que-es-la-asociacion","title":"\u00bfQu\u00e9 es la asociaci\u00f3n?:","text":"<ul> <li>La Asociaci\u00f3n entre clases se utiliza para representar relaciones entre diferentes clases. Esta relaci\u00f3n significa que una clase conoce a otra y tiene una referencia a ella.</li> </ul>"},{"location":"UML/Class%20UML/#como-se-representa","title":"\u00bfC\u00f3mo se representa?:","text":"<ul> <li>La asociaci\u00f3n se representa con una l\u00ednea que conecta dos clases en un diagrama de clases.</li> <li>Se suele leer como \"tiene...\"</li> <li>Tipo: Adicionalmente se le puede indicar un verbo para especificar el tipo de asociaci\u00f3n.</li> <li>Direccionalidad: Par\u00e9ntesis angulares se colocan junto al verbo para indicar direccionalidad</li> <li>Multiplicidad: Adicionalmente se pueden utilizar n\u00fameros o rangos que indican cu\u00e1ntas instancias de una clase est\u00e1n asociadas con una instancia de la otra clase.</li> </ul>"},{"location":"UML/Class%20UML/#links-uml-listado-de-referencias","title":"Links UML listado de referencias:","text":"<ul> <li>\ud83d\udd17 stefanhenneken.net, UML Class</li> <li> <p>\ud83d\udd17 www.lucidchart.com/tutorial-de-diagrama-de-clases-uml</p> </li> <li> <p>\ud83d\udd17 www.edrawsoft.com/uml-class-diagram-explained</p> </li> <li> <p>\ud83d\udd17 blog.visual-paradigm.com/what-are-the-six-types-of-relationships-in-uml-class-diagrams</p> </li> <li> <p>\ud83d\udd17 Ingenier\u00eda del Software: Fundamentos de UML usando Papyrus</p> </li> <li> <p>\ud83d\udd17 plantuml.com/class-diagram</p> </li> <li> <p>\ud83d\udd17 www.planttext.com</p> </li> <li> <p>\ud83d\udd17 UML Infosys Beckhoff</p> </li> <li> <p>\ud83d\udd17 Tutorial - Diagrama de Clases UML</p> </li> <li> <p>\ud83d\udd17 Curso UML. Diagrama de clases I. V\u00eddeo 9</p> </li> <li> <p>\ud83d\udd17 Curso UML. Diagrama de clases II. V\u00eddeo 10</p> </li> <li> <p>\ud83d\udd17 Curso UML. Diagramas de clases III. Traslado a c\u00f3digo I. V\u00eddeo 11</p> </li> </ul>"},{"location":"UML/Class%20UML/#link-al-video-de-youtube_nnn","title":"Link al Video de Youtube_NNN:","text":"<ul> <li>\ud83d\udd17</li> </ul>"},{"location":"UML/Statechart%20UML/","title":"StateChart UML","text":""},{"location":"UML/Statechart%20UML/#uml-state-chart","title":"UML State Chart:","text":""},{"location":"UML/Statechart%20UML/#links-uml-state-chart","title":"Links UML State Chart:","text":"<ul> <li> <p>\ud83d\udd17 content.helpme-codesys.com, UML State Chart</p> </li> <li> <p>\ud83d\udd17 www.infoplc.net, el-nuevo-uml-state-chart-en</p> </li> </ul>"},{"location":"UML/Statechart%20UML/#link-al-video-de-youtube_nnn","title":"Link al Video de Youtube_NNN:","text":"<ul> <li>\ud83d\udd17</li> </ul>"},{"location":"UML/UML/","title":"UML","text":""},{"location":"UML/UML/#uml-unified-modeling-language-o-lenguaje-unificado-de-modelado","title":"UML (Unified Modeling Language) o \u201cLenguaje Unificado de Modelado\u201d:","text":""},{"location":"UML/UML/#descripcion-general","title":"Descripci\u00f3n general:","text":"<p>UML (Lenguaje de modelado unificado) es un lenguaje gr\u00e1fico para la especificaci\u00f3n, dise\u00f1o y documentaci\u00f3n de software orientado a objetos. Proporciona una base universalmente comprensible para la discusi\u00f3n entre la programaci\u00f3n y otros departamentos dentro del desarrollo del sistema.</p> <p>El lenguaje de modelado unificado en s\u00ed mismo define 14 tipos de diagramas diferentes de dos categor\u00edas principales: </p>"},{"location":"UML/UML/#diagramas-de-estructura","title":"Diagramas de Estructura:","text":"<p>Los diagramas de estructura representan esquem\u00e1ticamente la arquitectura del software y se utilizan principalmente para modelado y an\u00e1lisis (por ejemplo, dise\u00f1o de proyectos, especificaci\u00f3n de requisitos del sistema y documentaci\u00f3n).</p> <p>En Codesys y en TwinCAT tendremos el diagrama:</p> <ul> <li>Diagrama de clase UML (tipo: diagrama de estructura)</li> </ul>"},{"location":"UML/UML/#diagramas-de-comportamiento","title":"Diagramas de Comportamiento:","text":"<p>Los diagramas de comportamiento son modelos ejecutables con sintaxis y sem\u00e1ntica \u00fanicas a partir de los cuales se puede generar directamente el c\u00f3digo de la aplicaci\u00f3n (arquitectura basada en modelos).</p> <p>En Codesys y en TwinCAT tendremos el diagrama:</p> <ul> <li>UML Statechart (tipo: diagrama de comportamiento)</li> </ul>"},{"location":"UML/UML/#oop-y-uml","title":"OOP y UML:","text":""},{"location":"UML/UML/#la-programacion-orientada-a-objetos-oop-y-uml-siempre-tienen-que-usarse-juntos","title":"\u00bfLa programaci\u00f3n orientada a objetos (OOP) y UML siempre tienen que usarse juntos?","text":"<ul> <li>El uso combinado de OOP y UML ofrece muchos beneficios, aunque no es obligatorio usarlo. La programaci\u00f3n de aplicaciones orientada a objetos tambi\u00e9n es posible sin utilizar UML.  Asimismo, UML tambi\u00e9n se puede utilizar en proyectos de PLC, que no se basan en la programaci\u00f3n orientada a objetos (UML Statechart).</li> </ul> <p>### \u00bfCu\u00e1les son los beneficios de usar POO y UML juntos?</p> <ul> <li>Para aprovechar al m\u00e1ximo la programaci\u00f3n orientada a objetos, la estructura de un software orientado a objetos debe dise\u00f1arse y crearse antes de la implementaci\u00f3n (por ejemplo, qu\u00e9 clases est\u00e1n disponibles, cu\u00e1l es su relaci\u00f3n, qu\u00e9 funcionalidades ofrecen, etc.).  Antes, durante y despu\u00e9s de la programaci\u00f3n, la documentaci\u00f3n ayuda a comprender, analizar y mantener el software.</li> <li>Como herramienta de an\u00e1lisis, dise\u00f1o y documentaci\u00f3n de software, UML ofrece opciones para planificar, crear y documentar la aplicaci\u00f3n.  UML es particularmente adecuado para implementaciones orientadas a objetos, ya que el software modular es particularmente adecuado para la representaci\u00f3n con la ayuda de un lenguaje gr\u00e1fico.</li> <li>Para la muestra, el diagrama de clases se utiliza para analizar y crear la estructura del programa.  Cuanto m\u00e1s modular sea la estructura del software, m\u00e1s f\u00e1cil y eficiente se puede utilizar el diagrama de clases (por ejemplo, representaci\u00f3n gr\u00e1fica de bloques de funciones separados con m\u00e9todos individuales para proporcionar las funcionalidades, etc.).</li> <li>El diagrama de estado se puede utilizar para especificar la secuencia de un sistema con eventos discretos.  Cuanto m\u00e1s coherente sea la orientaci\u00f3n a objetos y eventos de la estructura del software, m\u00e1s transparentes y eficaces se podr\u00e1n dise\u00f1ar las m\u00e1quinas de estado (por ejemplo, el comportamiento de los m\u00f3dulos/sistemas se basa en un modelo de estado con estados (como inicio, producci\u00f3n, pausa  ); dentro de los estados se llaman las funcionalidades correspondientes, las cuales se encapsulan en m\u00e9todos (como inicio, ejecuci\u00f3n, pausa, etc.).</li> </ul>"},{"location":"UML/UML/#links-uml","title":"Links UML:","text":"<ul> <li>\ud83d\udd17 UML \ud83d\udcd0 desde -10</li> <li>\ud83d\udd17 Curso UML</li> <li>\ud83d\udd17 Tutorial UML en espa\u00f1ol</li> <li>\ud83d\udd17 www.plccoder.com, twincat-uml-class-diagram</li> <li>\ud83d\udd17 content.helpme-codesys.com, uml_general</li> <li>\ud83d\udd17 content.helpme-codesys.com, Class Diagram Elements</li> <li>\ud83d\udd17 content.helpme-codesys.com, uml_class_diagram_clarification_terms</li> <li>\ud83d\udd17 online.visual-paradigm.com</li> <li>\ud83d\udd17 www.eclipse.org/papyrus</li> <li>\ud83d\udd17 sourcemaking.com/uml</li> <li>\ud83d\udd17 UML y Enterprise Architect desde cero</li> <li>\ud83d\udd17 Tutorial sobre UML y herramientas CASE</li> </ul>"},{"location":"UML/UML/#link-al-video-de-youtube_29","title":"Link al Video de Youtube_29:","text":"<ul> <li>\ud83d\udd17 029 - OOP IEC 61131-3 PLC -- UML - Descripci\u00f3n</li> </ul>"},{"location":"UML/relaciones/","title":"Relaciones","text":"<p>!!!! poner lo que he estado viendo en el curso de C# OOP de Noemi..!!! .Relaciones:</p>"},{"location":"UML/relaciones/#dependencias-entre-clase","title":"Dependencias entre Clase:","text":"<ul> <li>Clases: Establecen relaciones para solucionar el problema planteado.</li> <li> <p>Existen diferentes tipos de relaciones entre clases.</p> </li> <li> <p>Clasificaci\u00f3n seg\u00fan la Dependencia entre Clases:</p> <ul> <li>Agregaci\u00f3n:</li> <li>Composici\u00f3n: </li> </ul> </li> <li> <p>Niveles de dependencia entre clases:</p> <ul> <li>1 (relaci\u00f3n uno y solo uno)</li> <li>1..1 (relaci\u00f3n uno a uno)</li> <li>0..1 (relaci\u00f3n de cero a uno)</li> <li>M..N (relaci\u00f3n de M hasta N)</li> <li>M,N (relaci\u00f3n M \u00f3 N)</li> <li> <ul> <li>(relaci\u00f3n de cero a muchos)</li> </ul> </li> <li>1..* (relaci\u00f3n de uno a muchos y al menos uno)</li> </ul> </li> <li> <p>Dependencia entre Clases por Composici\u00f3n:</p> <ul> <li>Relaci\u00f3n estrecha entre clases.</li> <li>Componentes forman un todo.</li> <li>Todo formado por sus componentes. Si todo se elemina, tambi\u00e9n se eliminan sus componentes.</li> <li>Representaci\u00f3n en UML: <ul> <li>Se representa por un rombo relleno.</li> </ul> </li> </ul> </li> <li> <p>Dependencia entre Clases por Agregaci\u00f3n:</p> <ul> <li>Relaci\u00f3n d\u00e9bil entre clases.</li> <li>A un todo se le agregran componentes.</li> <li>El todo puede existir aunque no existan sus componentes.</li> <li>Los componentes pueden pertenecer a otros todos.</li> <li>Representaci\u00f3n en UMl:<ul> <li>Se representa por un rombo blanco o sin relleno.    </li> </ul> </li> </ul> </li> </ul> <p>Vamos a ver 2 tipos de relaciones:</p> <ul> <li>Asociaci\u00f3n.<ul> <li>De uno a uno: Una clase mantiene una asociaci\u00f3n de a uno con otra clase.</li> <li>De uno a muchos: Una clase mantiene una asociaci\u00f3n con otra clase a trav\u00e9s de una colecci\u00f3n.</li> <li>De muchos a muchos: La asociaci\u00f3n se da en ambos lados a trav\u00e9s de una colecci\u00f3n.</li> </ul> </li> <li>Colaboraci\u00f3n.<ul> <li>La colaboraci\u00f3n se da a trav\u00e9s de una referencia de una clase con el fin de lograr un cometido.</li> </ul> </li> </ul>"},{"location":"UML/relaciones/#link-al-video-de-youtube_nnn","title":"Link al Video de Youtube_NNN:","text":"<ul> <li>\ud83d\udd17</li> </ul>"},{"location":"principios/_principios%20OOP/","title":"4 Pilares","text":"<p> Principios OOP: (4 pilares) </p> <ul> <li>Abstracci\u00f3n -- La forma de plasmar algo hacia el c\u00f3digo para enfocarse en su uso. No enfocarnos tanto en que hay por detras del codigo si no en el uso de este.</li> <li>Encapsulamiento -- No toda la informaci\u00f3n de nuestro objeto es relevante y/o accesible para el usuario.</li> <li>Herencia -- Es la cualidad de heredar caracteristicas de otra clase. (EXTENDS)</li> <li>Polimorfismo -- Las m\u00faltiples formas que puede obtener un objeto si comparte la misma clase o interfaz. (IMPLEMENTS) </li> </ul> <p></p>"},{"location":"principios/_principios%20OOP/#links-de-principios-oop","title":"Links de Principios OOP:","text":"<ul> <li>\ud83d\udd17 github.com/Aliazzzz/OOP-Concept-Examples-in-CODESYS-V3</li> <li>\ud83d\udd17 4 PRINCIPIOS de la PROGRAMACI\u00d3N ORIENTADA A OBJETOS</li> </ul>"},{"location":"principios/_principios%20OOP/#link-al-video-de-youtube-020","title":"Link al Video de Youtube 020:","text":"<ul> <li>\ud83d\udd17 020 - OOP IEC 61131-3 PLC -- 4 Pilares OOP - Abstracci\u00f3n</li> </ul>"},{"location":"principios/abstraccion/","title":"Abstracci\u00f3n","text":""},{"location":"principios/abstraccion/#abstraccion","title":"ABSTRACCION:","text":"<p>La Abstracci\u00f3n es el proceso de ocultar informaci\u00f3n importante, mostrando solo lo informaci\u00f3n m\u00e1s esencial.  Reduce la complejidad del c\u00f3digo y a\u00edsla el impacto de los cambios. La abstracci\u00f3n se puede entender a partir de un ejemplo de la vida real: encender un televisor solo debe requieren hacer clic en un bot\u00f3n, ya que las personas no necesitan saber el proceso por el que pasa. Aunque ese proceso puede ser complejo e importante, no es necesario que el usuario sepa c\u00f3mo se implementa. La informaci\u00f3n importante que no se requiere est\u00e1 oculta para el usuario, reduciendo la complejidad del c\u00f3digo, mejorando la ocultaci\u00f3n de datos y la reutilizaci\u00f3n, haciendo as\u00ed que los Bloques de Funciones sean m\u00e1s f\u00e1ciles de implementar y modificar.</p> <p>La palabra clave ABSTRACT est\u00e1 disponible para bloques de funciones, m\u00e9todos y propiedades. Permite la implementaci\u00f3n de un proyecto PLC con niveles de abstracci\u00f3n.</p> <p>La abstracci\u00f3n es un concepto clave de la programaci\u00f3n orientada a objetos. Los diferentes niveles de abstracci\u00f3n contienen aspectos de implementaci\u00f3n generales o espec\u00edficos.</p>"},{"location":"principios/abstraccion/#aplicacion-de-la-abstraccion","title":"Aplicaci\u00f3n de la abstracci\u00f3n:","text":"<p>Es \u00fatil implementar funciones b\u00e1sicas o puntos en com\u00fan de diferentes clases en una clase b\u00e1sica abstracta. Se implementan aspectos espec\u00edficos en subclases no abstractas. El principio es similar al uso de una interfaz. Las interfaces corresponden a clases puramente abstractas que contienen s\u00f3lo m\u00e9todos y propiedades abstractas. Una clase abstracta tambi\u00e9n puede contener m\u00e9todos y propiedades no abstractos.</p> <p>Reglas para el uso de la palabra clave ABSTRACT:</p> <ul> <li>No se pueden instanciar bloques de funciones abstractas.</li> <li>Los bloques de funciones abstractas pueden contener m\u00e9todos y propiedades abstractos y no abstractos.</li> <li>Los m\u00e9todos abstractos o las propiedades no contienen ninguna implementaci\u00f3n (s\u00f3lo la declaraci\u00f3n).</li> <li>Si un bloque de funci\u00f3n contiene un m\u00e9todo o propiedad abstracta, debe ser abstracto.</li> <li>Los bloques de funciones abstractas deben extenderse para poder implementar los m\u00e9todos o propiedades abstractos.</li> <li>Por lo tanto: un FB derivado debe implementar los m\u00e9todos/propiedades de su FB b\u00e1sico o tambi\u00e9n debe definirse como abstracto.</li> </ul>"},{"location":"principios/abstraccion/#links-abstraccion","title":"Links Abstracci\u00f3n:","text":"<ul> <li> <p>\ud83d\udd17 ABSTRACT,www.plccoder.com</p> </li> <li> <p>\ud83d\udd17 ABSTRACION Concepto, Infosys Beckhoff</p> </li> </ul>"},{"location":"principios/abstraccion/#link-al-video-de-youtube-020","title":"Link al Video de Youtube 020:","text":"<ul> <li>\ud83d\udd17 020 - OOP IEC 61131-3 PLC -- 4 Pilares OOP - Abstracci\u00f3n</li> </ul>"},{"location":"principios/encapsulamiento/","title":"Encapsulamiento","text":""},{"location":"principios/encapsulamiento/#encapsulamiento","title":"Encapsulamiento:","text":""},{"location":"principios/encapsulamiento/#que-es-la-encapsulacion","title":"\u00bfQu\u00e9 es la Encapsulaci\u00f3n?","text":"<ul> <li>La encapsulaci\u00f3n agrupa propiedades y m\u00e9todos en un sola clase (bloque de funciones).</li> <li>La encapsulaci\u00f3n se utiliza para agrupar datos con los m\u00e9todos que operan en ellos y para ocultar datos en su interior, evitando que personas no autorizadas accedan directamente a la clase.</li> <li>Con encapsulaci\u00f3n tambi\u00e9n nos referimos a la capacidad de un bloque de funciones para ocultar datos y comportamientos que no son necesarios para el usuario. </li> <li>Es decir, hacemos una separaci\u00f3n entre una interfaz de bloques de funciones y su implementaci\u00f3n.</li> <li>Reduce la complejidad del c\u00f3digo y aumenta la reutilizaci\u00f3n. </li> <li>La separaci\u00f3n del c\u00f3digo permite la creaci\u00f3n de rutinas que pueden ser reutilizadas en lugar de copiar y pegar c\u00f3digo, reduciendo la complejidad del programa principal.</li> </ul>"},{"location":"principios/encapsulamiento/#por-que-es-importante-la-encapsulacion","title":"\u00bfPor qu\u00e9 es importante la encapsulaci\u00f3n?","text":"<ul> <li>Podemos especificar la accesibilidad de los miembros de un bloque de funciones.</li> <li>Ayuda a proteger sus datos de la corrupci\u00f3n accidental.</li> <li>Ayuda a mantener su c\u00f3digo limpio y extensible.</li> </ul>"},{"location":"principios/encapsulamiento/#como-logramos-la-encapsulacion","title":"\u00bfC\u00f3mo logramos la encapsulaci\u00f3n?","text":"<p>En Codesys y TwinCAT podemos usar un bloque de funciones para construir el proyecto original de un objeto (como una clase en C#). Con la ayuda de las propiedades y los m\u00e9todos podemos hacer 'puertos de entrada' a nuestros campos y funcionalidades internas.</p>"},{"location":"principios/encapsulamiento/#conclusion","title":"Conclusi\u00f3n:","text":"<p>La Encapsulaci\u00f3n es uno de los 4 pilares de OOP. La encapsulaci\u00f3n consiste en agrupar m\u00e9todos y propiedades en un bloque de funciones y ocultar y proteger datos que no son necesarios para el usuario. Esto nos ayuda a escribir c\u00f3digo S\u00d3LIDO y reutilizable. </p>"},{"location":"principios/encapsulamiento/#links-encapsulacion","title":"Links Encapsulacion:","text":"<ul> <li>\ud83d\udd17  www.plccoder.com, Encapsulation</li> <li>\ud83d\udd17  es.wikipedia.org, Encapsulamiento</li> </ul>"},{"location":"principios/encapsulamiento/#link-al-video-de-youtube-021","title":"Link al Video de Youtube 021:","text":"<ul> <li>\ud83d\udd17 021 - OOP IEC 61131-3 PLC -- 4 Pilares OOP - Encapsulamiento y Herencia</li> </ul>"},{"location":"principios/herencia/","title":"Herencia","text":""},{"location":"principios/herencia/#herencia","title":"Herencia:","text":"<ul> <li>La herencia permite al usuario crear clases basadas en otras clases. </li> <li>Las clases heredadas pueden utilizar las funcionalidades de la clase base, as\u00ed como algunas funcionalidades adicionales que el usuario puede definir. </li> <li>Elimina el c\u00f3digo redundante, evita copiar y pegar y facilita la expansi\u00f3n.</li> <li>Esto es muy \u00fatil porque permite ampliar o modificar (anular) las clases sin cambiar la implementaci\u00f3n del c\u00f3digo de la clase base.</li> </ul>"},{"location":"principios/herencia/#ejemplo-de-herencia","title":"Ejemplo de Herencia:","text":"<p>\u00bfQu\u00e9 tienen en com\u00fan un tel\u00e9fono fijo antiguo y un smartphone? </p> <ul> <li>Ambos pueden ser clasificados como tel\u00e9fonos. </li> </ul> <p>\u00bfDeber\u00edan clasificarse como objetos? </p> <ul> <li>No, ya que tambi\u00e9n definen las propiedades y comportamientos de un grupo de objetos. Un tel\u00e9fono inteligente funciona como un tel\u00e9fono normal, pero tambi\u00e9n es capaz de tomar fotograf\u00edas, navegar por Internet y hacer muchas otras cosas. Entonces, tel\u00e9fono fijo antiguo y el tel\u00e9fono inteligente son clases secundarias que ampl\u00edan la clase de tel\u00e9fono principal.</li> </ul>"},{"location":"principios/herencia/#definiciones-de-herencia","title":"Definiciones de Herencia:","text":"<ul> <li>Superclase: La clase cuyas caracter\u00edsticas se heredan se conoce como superclase (\u00f3 una clase base \u00f3 una clase principal \u00f3 clase padre). </li> <li>Subclase: La clase que hereda la otra clase se conoce como subclase (\u00f3 una clase derivada, clase extendida \u00f3 clase hija).</li> </ul>"},{"location":"principios/herencia/#links-herencia","title":"Links Herencia:","text":"<ul> <li>\ud83d\udd17 stefanhenneken.net,iec-61131-3-methods-properties-and-inheritance</li> </ul>"},{"location":"principios/herencia/#link-al-video-de-youtube-021","title":"Link al Video de Youtube 021:","text":"<ul> <li>\ud83d\udd17 021 - OOP IEC 61131-3 PLC -- 4 Pilares OOP - Encapsulamiento y Herencia</li> </ul>"},{"location":"principios/polimorfismo/","title":"Polimorfismo","text":""},{"location":"principios/polimorfismo/#polimorfismo","title":"Polimorfismo:","text":"<p>El concepto de polimorfismo se deriva de la combinaci\u00f3n de dos palabras: Poly (Muchos) y Morfismo (Forma). Refactoriza casos de cambio/declaraciones de casos feos y complejos. El polimorfismo permite que un objeto cambie su apariencia y desempe\u00f1o dependiendo de la situaci\u00f3n pr\u00e1ctica para poder realizar una determinada tarea.  Puede ser est\u00e1tico o din\u00e1mico:</p> <ul> <li>El polimorfismo est\u00e1tico ocurre cuando el compilador define el tipo de objeto;</li> <li>El polimorfismo din\u00e1mico se produce cuando el tipo se determina durante el tiempo de ejecuci\u00f3n, lo que hace posible para que una misma variable acceda a diferentes objetos mientras el programa se est\u00e1 ejecutando.</li> </ul>"},{"location":"principios/polimorfismo/#ejemplos-de-polimorfismo","title":"Ejemplos de Polimorfismo:","text":"<ul> <li> <p>Un buen ejemplo para explicar el polimorfismo es una navaja suiza. Una navaja suiza es una herramienta \u00fanica que incluye un mont\u00f3n de recursos que se pueden utilizar para resolver problemas diferentes. Al seleccionar la herramienta adecuada, se puede utilizar una navaja suiza para realizar un determinado conjunto de tareas valiosas.</p> </li> <li> <p>De la manera dual, otro ejemplo podria ser un bloque sumador simple que se adapta para hacer frente a,  por ejemplo, los tipos de datos int, float, string y time es un ejemplo de un polim\u00f3rfico recurso de programaci\u00f3n.</p> </li> </ul>"},{"location":"principios/polimorfismo/#como-conseguir-el-polimorfismo","title":"\u00bfComo conseguir el Polimorfismo?","text":"<p>El polimorfismo se puede obtener gracias a las Interfaces y/o las Clases Abstractas.</p> <ul> <li> <p>Interface: (INTERFACE)</p> <ul> <li>Son un contrato que obliga a una clase a implementar las propiedades y/o m\u00e9todos definidos.</li> <li>Son una plantilla (sin l\u00f3gica).</li> </ul> </li> <li> <p>Clases Abstractas: (ABSTRACT)</p> <ul> <li>Son Clases que no se pueden instanciar, solo pueden ser implementadas a trav\u00e9s de la herencia.</li> </ul> </li> <li> <p>Diferencias:</p> Clases abstractas Interfaces 1.- Limitadas a una sola implementaci\u00f3n. 1. No tiene limitaci\u00f3n de implementaci\u00f3n. 2.- Pueden definir comportamiento base. 2. Expone propiedades y m\u00e9todos abstractos (sin l\u00f3gica). </li> </ul> <p>Tambien se puede conseguir el Polimorfismo por Referencia y/o por Punteros:</p> <ul> <li> <p>Referencia: (REFERENCE)</p> </li> <li> <p>Puntero: (POINTER)</p> </li> </ul>"},{"location":"principios/polimorfismo/#links-polimorfismo","title":"Links Polimorfismo:","text":"<ul> <li> <p>\ud83d\udd17 polymorphism, www.plccoder.com</p> </li> <li> <p>\ud83d\udd17 abstract, www.plccoder.com</p> </li> <li> <p>\ud83d\udd17 stefanhenneken.net,iec-61131-3-methods-properties-and-inheritance</p> </li> <li> <p>\ud83d\udd17 AT&amp;U, CODESYS - Runtime polymorphism using inheritance (OOP)</p> </li> <li> <p>\ud83d\udd17 AT&amp;U,CODESYS - Runtime polymorphism using an ITF (OOP)</p> </li> </ul>"},{"location":"principios/polimorfismo/#link-al-video-de-youtube-022","title":"Link al Video de Youtube 022:","text":"<ul> <li>\ud83d\udd17 022 - OOP IEC 61131-3 PLC -- 4 Pilares OOP - Polimorfismo</li> </ul>"},{"location":"solid/Principio%20de%20Abierto_Cerrado/","title":"OCP - Principio de Abierto/Cerrado","text":""},{"location":"solid/Principio%20de%20Abierto_Cerrado/#principio-de-abiertocerrado-openclosed-principle-ocp","title":"Principio de Abierto/Cerrado --  (Open/Closed Principle) OCP :","text":""},{"location":"solid/Principio%20de%20Abierto_Cerrado/#la-definicion-del-principio-abiertocerrado","title":"La definici\u00f3n del principio abierto/cerrado:","text":"<p>El Principio Abierto/Cerrado (OCP) fue formulado por Bertrand Meyer en 1988 y establece:</p> <p>Una entidad de software debe estar abierta a extensiones, pero al mismo tiempo cerrada a modificaciones.</p> <p>Entidad de software: Esto significa una clase, bloque de funci\u00f3n, m\u00f3dulo, m\u00e9todo, servicio, etc...</p> <p>Abierto: el comportamiento de los m\u00f3dulos de software debe ser extensible.</p> <p>Cerrado: la capacidad de expansi\u00f3n no debe lograrse cambiando el software existente.</p> <p>Cuando Bertrand Meyer defini\u00f3 el Principio Abierto/Cerrado (OCP) a fines de la d\u00e9cada de 1980, la atenci\u00f3n se centr\u00f3 en el lenguaje de programaci\u00f3n C++. Usaba herencia, bien conocida en el mundo orientado a objetos. La disciplina de la orientaci\u00f3n a objetos, que a\u00fan era joven en ese momento, promet\u00eda grandes mejoras en la reutilizaci\u00f3n y la mantenibilidad al permitir que clases concretas se usaran como clases base para nuevas clases.</p> <p>Cuando Robert C. Martin se hizo cargo del principio de Bertrand Meyer en la d\u00e9cada de 1990, lo implement\u00f3 t\u00e9cnicamente de manera diferente. C ++ permite el uso de herencia m\u00faltiple, mientras que la herencia m\u00faltiple rara vez se encuentra en los lenguajes de programaci\u00f3n m\u00e1s nuevos. Por este motivo, Robert C. Martin se centr\u00f3 en el uso de interfaces. Se puede encontrar m\u00e1s informaci\u00f3n al respecto en el libro (enlace publicitario de Amazon *) Arquitectura limpia: el manual pr\u00e1ctico para el dise\u00f1o de software profesional.</p>"},{"location":"solid/Principio%20de%20Abierto_Cerrado/#resumen","title":"Resumen:","text":"<p>Sin embargo, adherirse al principio abierto/cerrado (OCP) conlleva el riesgo de un exceso de ingenier\u00eda. La opci\u00f3n de extensiones solo debe implementarse donde sea espec\u00edficamente necesario. El software no puede dise\u00f1arse de tal manera que todas las extensiones imaginables puedan implementarse sin realizar ajustes en el c\u00f3digo fuente.</p>"},{"location":"solid/Principio%20de%20Abierto_Cerrado/#ejemplo","title":"Ejemplo:","text":"<p><pre><code>FUNCTION_BLOCK Vehiculo\nVAR_INPUT\nvelocidad : REAL;\nEND_VAR\n\n// m\u00e9todo para obtener la velocidad\ngetVelocidad() : REAL;\nEND_FUNCTION_BLOCK\n\nFUNCTION_BLOCK Coche EXTENDS Vehiculo // extiende la funci\u00f3n Vehiculo\nVAR_INPUT\nvelocidadMaxima : REAL;\nEND_VAR\n\n// m\u00e9todo para obtener la velocidad m\u00e1xima\ngetVelocidadMaxima() : REAL;\nEND_FUNCTION_BLOCK\n\nFUNCTION_BLOCK Moto EXTENDS Vehiculo // extiende la funci\u00f3n Vehiculo\nVAR_INPUT\naceleracion : REAL;\nEND_VAR\n\n// m\u00e9todo para obtener la aceleraci\u00f3n\ngetAceleracion() : REAL;\nEND_FUNCTION_BLOCK\n</code></pre> </p> <p>De esta manera, la clase \"Vehiculo\" est\u00e1 cerrada para modificaciones directas y abierta para extensiones a trav\u00e9s de las nuevas clases \"Coche\" y \"Moto\". Cada nueva clase agrega funcionalidades espec\u00edficas sin modificar directamente la clase original.</p>"},{"location":"solid/Principio%20de%20Abierto_Cerrado/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 stefanhenneken.net, EC 61131-3: SOLID \u2013 The Open/Closed Principle</p> </li> <li> <p>\ud83d\udd17 hdeleon.net, Principios SOLID: Principio de Abierto/Cerrado OCP</p> </li> <li> <p>\ud83d\udd17 El Camino Dev, El Principio Abierto Cerrado con C# | Principios SOLID</p> </li> <li> <p>\ud83d\udd17 makigas: aprende a programar, SOLID: Principio Abierto-Cerrado (OCP)</p> </li> <li> <p>\ud83d\udd17 tech.tribalyte.eu, blog-solid-open-closed</p> </li> </ul>"},{"location":"solid/Principio%20de%20Abierto_Cerrado/#link-al-video-de-youtube-025","title":"Link al Video de Youtube 025:","text":"<ul> <li>\ud83d\udd17 025 - OOP IEC 61131-3 PLC -- SOLID - OCP</li> </ul>"},{"location":"solid/Principio%20de%20Inversion%20de%20Dependencia/","title":"DIP - Principio de Inversi\u00f3n de Dependencia","text":""},{"location":"solid/Principio%20de%20Inversion%20de%20Dependencia/#principio-de-inversion-de-dependencia-dependency-inversion-principle-dip","title":"Principio de Inversi\u00f3n de Dependencia -- (Dependency Inversion Principle) DIP :","text":"<p>El principio de inversi\u00f3n de dependencia establece que los m\u00f3dulos de nivel superior no deben depender de los m\u00f3dulos de nivel inferior, sino que ambos deben depender de abstracciones.</p>"},{"location":"solid/Principio%20de%20Inversion%20de%20Dependencia/#ejemplo","title":"Ejemplo:","text":"<pre><code>INTERFACE I_Conexion\n// interfaz para la conexi\u00f3n\nMETHODS\nEstablecerConexion : BOOL; // m\u00e9todo para establecer la conexi\u00f3n\nEND_INTERFACE\n\nFUNCTION_BLOCK ConexionSerial IMPLEMENTS I_Conexion // implementa la interfaz I_Conexion\n// implementaci\u00f3n para la conexi\u00f3n serial\nEND_FUNCTION_BLOCK\n\nFUNCTION_BLOCK ConexionEthernet IMPLEMENTS I_Conexion // implementa la interfaz I_Conexion\n// implementaci\u00f3n para la conexi\u00f3n ethernet\nEND_FUNCTION_BLOCK\n\nFUNCTION_BLOCK Dispositivo\n\n// constructor\nDispositivo(conexion);\n\n// m\u00e9todo para establecer la conexi\u00f3n\nestablecerConexion();\n\nEND_FUNCTION_BLOCK\n</code></pre> <ul> <li> <p>Esto permite que se pueda pasar cualquier objeto que implemente la interfaz <code>I_Conexion</code>, lo que cumple con el principio de inversi\u00f3n de dependencias.</p> </li> <li> <p>Adem\u00e1s, se utiliza el m\u00e9todo <code>EstablecerConexion</code> definido en la interfaz <code>I_Conexion</code>, lo que demuestra c\u00f3mo se puede utilizar una abstracci\u00f3n (la interfaz) para trabajar con diferentes implementaciones concretas de manera uniforme.</p> </li> </ul>"},{"location":"solid/Principio%20de%20Inversion%20de%20Dependencia/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 stefanhenneken.net,iec-61131-3-solid-the-dependency-inversion-principle</p> </li> <li> <p>\ud83d\udd17 Twincontrols__Dependency Injection</p> </li> <li> <p>\ud83d\udd17 tech.tribalyte.eu, blog-principios-solid-dependency</p> </li> </ul>"},{"location":"solid/Principio%20de%20Inversion%20de%20Dependencia/#link-al-video-de-youtube-028","title":"Link al Video de Youtube 028:","text":"<ul> <li>\ud83d\udd17 028 - OOP IEC 61131-3 PLC -- SOLID - DIP</li> </ul>"},{"location":"solid/Principio%20de%20Responsabilidad%20Unica/","title":"SRP - Principio de Responsabilidad \u00danica","text":""},{"location":"solid/Principio%20de%20Responsabilidad%20Unica/#principio-de-responsabilidad-unica-single-responsibility-principle-srp","title":"Principio de Responsabilidad \u00danica -- (Single Responsibility Principle) SRP :","text":"<p>El principio de responsabilidad \u00fanica establece que una clase debe tener una sola responsabilidad en un programa.</p>"},{"location":"solid/Principio%20de%20Responsabilidad%20Unica/#ejemplo","title":"Ejemplo :","text":"<p>Por ejemplo, en lugar de tener una clase \"Empleado\" que maneje tanto la informaci\u00f3n personal como el registro de tiempo, se deben crear dos clases separadas: \"Empleado\" para la informaci\u00f3n personal y \"RegistroDeTiempo\" para el registro de tiempo. De esta manera, cada clase se enfoca en una sola tarea y es m\u00e1s f\u00e1cil de mantener y modificar.</p> <p>En lugar de tener una Clase que maneje todo, creamos dos Clases separadas:</p> <pre><code>FUNCTION_BLOCK Empleado\nVAR_INPUT\nNombre : STRING;\nApellido : STRING;\nCorreoElectronico : STRING;\nEND_VAR\n\n// constructor\nEmpleado(ST_Empleado);\n\n// getters y setters\nnombre();\napellido();\ncorreoElectronico();\n\nEND_FUNCTION_BLOCK\n</code></pre> <p><pre><code>FUNCTION_BLOCK RegistroDeTiempo\nVAR_INPUT\nempleado : ST_Empleado; // instancia de la funci\u00f3n Empleado\nhoraEntrada : DATE_AND_TIME;\nhoraSalida : DATE_AND_TIME;\nEND_VAR\n\n// constructor\nRegistroDeTiempo(ST_RegistroDeTiempoEmpleado);\n\n// getters y setters\nempleado();\nhoraEntrada();\nhoraSalida();\n\nEND_FUNCTION_BLOCK\n</code></pre> </p> <p>De esta manera, la Clase \"Empleado\" solo maneja la informaci\u00f3n personal del empleado y la Clase \"RegistroDeTiempo\" solo maneja el registro de tiempo. Cada Clase tiene una sola responsabilidad y es m\u00e1s f\u00e1cil de mantener y modificar en el futuro.</p>"},{"location":"solid/Principio%20de%20Responsabilidad%20Unica/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 stefanhenneken.net,iec-61131-3-solid-the-single-responsibility-principle</p> </li> <li> <p>\ud83d\udd17 hdeleon.net, Principios SOLID: El Principio de Responsabilidad \u00danica SRP</p> </li> <li> <p>\ud83d\udd17 El Camino Dev, Principio de Responsabilidad \u00danica en C# | Principios SOLID</p> </li> <li> <p>\ud83d\udd17 makigas: aprende a programar, SOLID: Principio de Responsabilidad \u00danica (SRP)</p> </li> <li> <p>\ud83d\udd17 tech.tribalyte.eu, blog-solid-single-responsability</p> </li> </ul>"},{"location":"solid/Principio%20de%20Responsabilidad%20Unica/#link-al-video-de-youtube-024","title":"Link al Video de Youtube 024:","text":"<ul> <li>\ud83d\udd17 024 - OOP IEC 61131-3 PLC -- SOLID - SRP</li> </ul>"},{"location":"solid/Principio%20de%20Segregacion%20de%20Interfaz/","title":"ISP - Principio de Segregaci\u00f3n de Interfaz","text":""},{"location":"solid/Principio%20de%20Segregacion%20de%20Interfaz/#principio-de-segregacion-de-interfaz-interface-segregation-principle-isp","title":"Principio de Segregaci\u00f3n de Interfaz -- (Interface Segregation Principle) ISP :","text":"<ul> <li>El principio de segregaci\u00f3n de interfaz establece que una clase no debe implementar interfaces que no utilice y que debe dividirse en interfaces m\u00e1s peque\u00f1as y espec\u00edficas.</li> <li>El principio de segregaci\u00f3n de interfaz se debe de mirar desde el lado de los clientes que implementan las interfaces que no tengan metodos y/o propiedades que no tengan sentido para ese cliente.</li> </ul>"},{"location":"solid/Principio%20de%20Segregacion%20de%20Interfaz/#ejemplo","title":"Ejemplo:","text":"<p><pre><code>INTERFACE I_AveVoladora\n// interfaz para las aves voladoras\nMETHODS\nVolar : BOOL; // m\u00e9todo para volar\nEND_INTERFACE\n\nINTERFACE I_AveNadadora\n// interfaz para las aves nadadoras\nMETHODS\nNadar : BOOL; // m\u00e9todo para nadar\nEND_INTERFACE\n\nINTERFACE I_AveCorredora\n// interfaz para las aves corredoras\nMETHODS\nCorrer : BOOL; // m\u00e9todo para correr\nEND_INTERFACE\n\nFUNCTION_BLOCK Pato IMPLEMENTS I_AveVoladora, I_AveNadadora\n// implementa las interfaces I_AveVoladora e I_AveNadadora\nVAR_INPUT\nvelocidad : REAL;\nalturaMaxima : REAL;\ntiempoBuceo : TIME;\nEND_VAR\n\n// implementaci\u00f3n para el pato\n// m\u00e9todos para volar y nadar\n\nEND_FUNCTION_BLOCK\n\nFUNCTION_BLOCK Aguila IMPLEMENTS I_AveVoladora\n// implementa la interfaz I_AveVoladora solamente\nVAR_INPUT\nvelocidad : REAL;\nalturaMaxima : REAL;\nEND_VAR\n\n// implementaci\u00f3n para el \u00e1guila\n// m\u00e9todo para volar\n\nEND_FUNCTION_BLOCK\n\nFUNCTION_BLOCK Avestruz IMPLEMENTS I_AveCorredora\n// implementa la interfaz I_AveCorredora solamente\nVAR_INPUT\nvelocidad : REAL;\ntiempoCorriendo : TIME;\nEND_VAR\n\n// implementaci\u00f3n para el avestruz\n// m\u00e9todo para correr\n\nEND_FUNCTION_BLOCK\n</code></pre> </p> <ul> <li>De esta manera, cada clase tiene solo los m\u00e9todos necesarios y se divide en interfaces m\u00e1s peque\u00f1as y espec\u00edficas. Adem\u00e1s, se utilizan interfaces en lugar de function blocks para implementar el principio de segregaci\u00f3n de interfaz. </li> <li>Esto permite una mayor flexibilidad y evita la necesidad de implementar m\u00e9todos innecesarios en una clase.</li> </ul>"},{"location":"solid/Principio%20de%20Segregacion%20de%20Interfaz/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 stefanhenneken.net,iec-61131-3-solid-the-interface-segregation-principle</p> </li> <li> <p>\ud83d\udd17 IEC 61131-3: SOLID \u2013 The Interface Segregation Principle</p> </li> <li> <p>\ud83d\udd17 \ud83e\udd13\u00a1PATRONES de DISE\u00d1O de Typescript que te AYUDAR\u00c1N! Gu\u00eda + Interface Segregation Principle | PT 1.</p> </li> <li> <p>\ud83d\udd17 CodelyTV - Redescubre la programaci\u00f3n, Principio de Segregaci\u00f3n de Interfaces - SOLID</p> </li> <li> <p>\ud83d\udd17 CodelyTV - Redescubre la programaci\u00f3n, Errores comunes al dise\u00f1ar Interfaces - #SOLID - ISP</p> </li> <li> <p>\ud83d\udd17 hdeleon.net, Principios SOLID: Principio de Segregaci\u00f3n de Interfaces ISP</p> </li> <li> <p>\ud83d\udd17 DevExpert - Formaci\u00f3n Android &amp; Kotlin, Principio de SEGREGACI\u00d3N de INTERFACES \u26a0 Est\u00e1s usando mal las interfaces [SOLID] \ud83d\udfe1</p> </li> <li> <p>\ud83d\udd17 Segregaci\u00f3n de Interfaces - Jos\u00e9 Luis Rodr\u00edguez</p> </li> <li> <p>\ud83d\udd17 makigas: aprende a programar, SOLID: Principio de Segregaci\u00f3n de Interfaz (ISP)</p> </li> <li> <p>\ud83d\udd17 tech.tribalyte.eu, blog-principios-solid-interface-segregation</p> </li> </ul>"},{"location":"solid/Principio%20de%20Segregacion%20de%20Interfaz/#link-al-video-de-youtube-027","title":"Link al Video de Youtube 027:","text":"<ul> <li>\ud83d\udd17 027 - OOP IEC 61131-3 PLC -- SOLID - ISP</li> </ul>"},{"location":"solid/Principio%20de%20Sustitucion%20de%20Liskov/","title":"LSP - Principio de Sustituci\u00f3n de Liskov","text":""},{"location":"solid/Principio%20de%20Sustitucion%20de%20Liskov/#principio-de-sustitucion-de-liskov-liskov-substitution-principle-lsp","title":"Principio de Sustituci\u00f3n de Liskov -- (Liskov Substitution Principle) LSP :","text":"<ul> <li> <p>Este principio de la programaci\u00f3n orientada a objetos debe su nombre a Barbara Liskov, reconocida ingeniera de software que fue la primera mujer de los Estados Unidos en conseguir un doctorado en Ciencias de la Computaci\u00f3n, ganadora de un premio Turing y nombrada doctora honoris causa por la UPM.</p> </li> <li> <p>El principio de sustituci\u00f3n de Liskov establece que una instancia de una subclase debe poder ser utilizada en cualquier lugar donde se espera una instancia de la clase base, sin afectar el comportamiento del programa.</p> </li> </ul>"},{"location":"solid/Principio%20de%20Sustitucion%20de%20Liskov/#ejemplo","title":"Ejemplo:","text":"<p><pre><code>INTERFACE I_Mover\nMETHODS Mover : REAL; // m\u00e9todo para mover el veh\u00edculo\nVAR_INPUT\nVelocidad_Deseada : REAL;\nEND_VAR\nEND_INTERFACE\n\nFUNCTION_BLOCK Vehiculo IMPLEMENTS I_Mover\n// clase base para los veh\u00edculos\nVAR_INPUT\nvelocidad : REAL;\nEND_VAR\nMETHODS Mover : REAL; // m\u00e9todo para mover el veh\u00edculo\nMover := Velocidad_Deseada;      END_FUNCTION_BLOCK\n\nFUNCTION_BLOCK Coche1 EXTENDS Vehiculo\n// subclase para los coches\nVAR_INPUT\nvelocidadMaxima : REAL;\nEND_VAR\nMETHODS Mover : REAL; // m\u00e9todo para mover el Coche\nMover := Velocidad_Deseada * velocidadMaxima;   END_FUNCTION_BLOCK\n\nFUNCTION_BLOCK Moto1 EXTENDS Vehiculo\n// subclase para las motos\nVAR_INPUT\nAceleracion : REAL;\nEND_VAR\nMETHODS Mover : REAL; // m\u00e9todo para mover la Moto\nMover := Velocidad_Deseada * Aceleracion;\nEND_FUNCTION_BLOCK\n\nFUNCTION_BLOCK Conductor\nVAR_INPUT\nvehiculo : REFERENCE TO Vehiculo; // referencia a la clase base Vehiculo\nEND_VAR\nMETHODS Mover : REAL; // m\u00e9todo para mover el veh\u00edculo   \n// m\u00e9todo para mover el veh\u00edculo a la velocidad especificada\nTHIS^.vehiculo.Mover(velocidad);\nEND_FUNCTION_BLOCK\n</code></pre> </p> <ul> <li> <p>En este ejemplo, se utiliza la subclase <code>Coche1</code> y <code>Moto1</code> como instancias de la clase base <code>Vehiculo</code>, lo que cumple con el principio de sustituci\u00f3n de Liskov. Esto significa que se puede utilizar cualquier instancia de <code>Coche1</code> o <code>Moto1</code> donde se espera una instancia de <code>Vehiculo</code>, sin afectar el comportamiento del programa.</p> </li> <li> <p>Adem\u00e1s, cada subclase tiene un m\u00e9todo <code>Mover</code> que se utiliza para mover el veh\u00edculo, lo que demuestra c\u00f3mo se puede utilizar la misma interfaz <code>I_Mover</code> (el mismo nombre de m\u00e9todo) para diferentes implementaciones concretas, mediante la sobreescritura del metodo mover que tiene la clase <code>Vehiculo</code>.</p> </li> </ul>"},{"location":"solid/Principio%20de%20Sustitucion%20de%20Liskov/#links","title":"Links:","text":"<ul> <li> <p>\ud83d\udd17 stefanhenneken.net,iec-61131-3-solid-the-liskov-substitution-principle</p> </li> <li> <p>\ud83d\udd17 hdeleon.net, Principios SOLID: Principio de Sustituci\u00f3n de Liskov LSP</p> </li> <li> <p>\ud83d\udd17 makigas: aprende a programar, SOLID: Principio de Sustituci\u00f3n de Liskov (LSP)</p> </li> <li> <p>\ud83d\udd17 tech.tribalyte.eu, blog-principio-solid-liskov</p> </li> </ul>"},{"location":"solid/Principio%20de%20Sustitucion%20de%20Liskov/#link-al-video-de-youtube-026","title":"Link al Video de Youtube 026:","text":"<ul> <li>\ud83d\udd17 026 - OOP IEC 61131-3 PLC -- SOLID - LSP</li> </ul>"},{"location":"solid/_SOLID/","title":"SOLID","text":"<ul> <li>Propuesta por Robert C.Martin en el 2000.</li> <li>Son recomendaciones para escribir un c\u00f3digo sostenible,mantenible,escalable y robusto.</li> <li> <p>Beneficios:</p> <ul> <li>Alta Cohesi\u00f3n. Colaboracion entre clases.</li> <li>Bajo Acoplamiento. Evitar que una clase dependa fuertemente de otra clase.</li> </ul> </li> <li> <p>Principio de Responsabilidad \u00danica: Una clase debe tener una raz\u00f3n para existir mas no para cambiar.</p> </li> <li>Principio de Abierto/Cerrado: Las piezas del software deben estar abiertas para la extensi\u00f3n pero cerradas para la modificaci\u00f3n.</li> <li>Principio de Sustituci\u00f3n de Liskov: Las clases subtipos deber\u00edan ser reemplazables por sus clases padres.</li> <li>Principio de Segregaci\u00f3n de Interfaz: Varias interfaces funcionan mejor que una sola.</li> <li>Principio de Inversi\u00f3n de Dependencia: Clases de alto nivel no deben depender de las clases bajo nivel.</li> </ul> <p>Los principios SOLID son una parte esencial del desarrollo de software orientado a objetos y han demostrado ser herramientas valiosas para desarrollar c\u00f3digo limpio, mantenible y extensible. En la tecnolog\u00eda de automatizaci\u00f3n industrial, especialmente en la programaci\u00f3n de controladores con IEC 61131-3, es de particular importancia desarrollar sistemas robustos y confiables.</p> <p></p> <p>Adem\u00e1s de los principios SOLID, existen otros principios como:</p> <p></p>"},{"location":"solid/_SOLID/#keep-it-simple-stupid-kiss","title":"Keep It Simple, Stupid (KISS).","text":"<pre><code>\" Mantenlo Simple, Est\u00fapido \"\n</code></pre> <ul> <li> <p>Evite la complejidad innecesaria en su c\u00f3digo, use soluciones simples para resolver problemas.</p> </li> <li> <p>Ejemplo: En lugar de escribir un algoritmo personalizado para generar un n\u00famero aleatorio dentro de un rango, use el generador de n\u00fameros aleatorios incorporado en su lenguaje de programaci\u00f3n.</p> </li> </ul>"},{"location":"solid/_SOLID/#dont-repeat-yourself-dry","title":"Don't Repeat Yourself (DRY).","text":"<pre><code>\" No te repitas \"\n</code></pre> <ul> <li> <p>Cada pieza de conocimiento debe tener una representaci\u00f3n \u00fanica, inequ\u00edvoca y autorizada dentro de un sistema.</p> </li> <li> <p>Evite la duplicaci\u00f3n de c\u00f3digo y mantenga su base de c\u00f3digo lo m\u00e1s mantenible y escalable posible.</p> </li> <li> <p>Ejemplo: En lugar de copiar y pegar el mismo bloque de c\u00f3digo en varios lugares, cree una funci\u00f3n o m\u00f3dulo que se pueda reutilizar.</p> </li> </ul>"},{"location":"solid/_SOLID/#law-of-demeter-lod","title":"Law Of Demeter (LOD).","text":"<pre><code>\" Habla Solo con tus amigos inmediatos \"\n</code></pre> <ul> <li> <p>La Ley de Demeter (LOD) en programaci\u00f3n es un principio que establece que un objeto debe tener acceso limitado a los objetos relacionados con \u00e9l y solo interactuar con los objetos m\u00e1s cercanos a \u00e9l. En resumen, un objeto no debe conocer la estructura interna de otros objetos y solo debe comunicarse con ellos a trav\u00e9s de una interfaz limitada.</p> </li> <li> <p>Ejemplo: Si tienes una clase \"Persona\" que tiene un m\u00e9todo \"getNombre()\" y otra clase \"Empresa\" que tiene un m\u00e9todo \"getPersona()\". En lugar de acceder directamente al nombre de la persona desde la clase Empresa, se deber\u00eda llamar al m\u00e9todo \"getNombre()\" de la clase Persona desde fuera de la clase Empresa, para evitar una dependencia innecesaria y mantener una comunicaci\u00f3n limitada entre objetos.</p> </li> </ul>"},{"location":"solid/_SOLID/#you-aint-gonna-need-it-yagni","title":"You Ain't Gonna Need It (YAGNI).","text":"<pre><code>\" No lo vas a necesitar \"\n</code></pre> <ul> <li> <p>No agregue funcionalidad a su c\u00f3digo hasta que realmente lo necesite.</p> </li> <li> <p>Ejemplo: No agregue una funci\u00f3n a su aplicaci\u00f3n que permita a los usuarios cambiar el color de la fuente si no es parte de los requisitos principales.</p> </li> </ul> <p>Todos estos principios tienen el objetivo com\u00fan de mejorar la mantenibilidad y la reutilizaci\u00f3n del software.</p> <p>Los principios SOLID no son reglas o leyes que deban seguirse estrictamente. Son pautas que pueden ayudarnos a mejorar nuestra calidad de c\u00f3digo y habilidades de dise\u00f1o. No est\u00e1n destinados a ser aplicados ciega o dogm\u00e1ticamente. Est\u00e1n destinados a ser utilizados con sentido com\u00fan y juicio.</p>"},{"location":"solid/_SOLID/#links-solid","title":"Links SOLID:","text":"<ul> <li> <p>\ud83d\udd17 C\u00f3mo explicar conceptos de programaci\u00f3n orientada a objetos a un ni\u00f1o de 6 a\u00f1os</p> </li> <li> <p>\ud83d\udd17 iec-61131-3-solid-five-principles-for-better-software,stefanhenneken.net</p> </li> <li> <p>\ud83d\udd17 Libro SOLID IEC61131-3 en Aleman de Stefanhenneken</p> </li> <li> <p>\ud83d\udd17 kentcdodds.com,aha-programming</p> </li> <li> <p>\ud83d\udd17 Qu\u00e9 son los principios SOLID ? Por qu\u00e9 son tan importantes y ver\u00e1s que ya los aplicas sin saberlo !!</p> </li> <li> <p>\ud83d\udd17 Los Principios SOLID explicados \u00a1Con ejemplos! 100% PR\u00c1CTICO</p> </li> <li> <p>\ud83d\udd17 C\u00f3mo implementar los principios SOLID en JAVA</p> </li> <li> <p>\ud83d\udd17 Principios de programaci\u00f3n SOLID (#Shorts)</p> </li> </ul>"},{"location":"solid/_SOLID/#link-al-video-de-youtube-023","title":"Link al Video de Youtube 023:","text":"<ul> <li>\ud83d\udd17 023 - OOP IEC 61131-3 PLC -- SOLID</li> </ul>"}]}